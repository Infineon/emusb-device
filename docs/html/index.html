<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>emusb-device</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">emusb-device</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SEGGER emUSB-Device for ModusToolbox User Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><br />
<a href="https://www.segger.com/products/connectivity/emusb-device/"><b>emUSB-Device</b></a> enables easy integration of USB functionality into an embedded system.Multiple standard classes are provided that allow embedded systems to behave as standard USB devices and communicate with any host like Windows, Linux and Mac systems. Infineon has licensed emUSB-Device from SEGGER and offers it for free to its customers. This middleware library provides emUSB-Device in the form of pre-build libraries.</p>
<p><b>Features:</b></p><ul>
<li>High performance</li>
<li>Can be used with or without an RTOS</li>
<li>Easy to use</li>
<li>Easy to port</li>
<li>No custom USB host driver necessary</li>
</ul>
<p><b>Supported USB Device Classes:</b></p><ul>
<li>Bulk communication</li>
<li>Communication Device Class (CDC)</li>
<li>Human Interface Device Class (HID)</li>
<li>Mass Storage Device Class (MSD)</li>
<li>Media Transfer Protocol Class (MTP)</li>
<li>Printer Class</li>
<li>Virtual Mass Storage Component (VirtualMSD)</li>
<li>Vendor Specific Class (VSC)</li>
</ul>
<p><b>Device families supported by the Middleware:</b></p><ul>
<li>CAT1A</li>
</ul>
<h1><a class="anchor" id="section_emusb_device_general"></a>
General Description</h1>
<p>This manual provides only the basic concepts of emUSB-Device and integration specifics of the emUSB-Device into ModusToolbox flow. For a detail description of the emUSB-Device features, implementation, and APIs, refer to: <a href="./../../docs/UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a>.</p>
<p><a class="el" href="index.html#section_emusb_device_quick_start">Quick Start</a> is available in this API Reference Guide.</p>
<p><b>emUSB-Device consists of the following layers:</b></p><ul>
<li>The driver for hardware access</li>
<li>The emUSB-Device core</li>
<li>The USB class driver or the bulk communication component</li>
</ul>
<p>emUSB-Device core and the USB class drivers are device-independent, while the driver for hardware access is applicable only for one device family. The driver is selected in the USBD_X_Config() function, the template of implementation of USBD_X_Config() is in the export/Config folder.</p>
<p>The drivers for emUSB-Device can support not all available features and may need to be configured in a special manners, refer to the: <a href="./../../docs/UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> Device driver specifics chapter.</p>
<p><b>Supported Drivers by the Device family</b></p>
<table class="doxtable">
<tr>
<th>Device family</th><th>Drivers</th><th>Pointer to the driver API structure </th></tr>
<tr>
<td>CAT1A </td><td>Cypress PSoC 6 driver </td><td>USB_Driver_Cypress_PSoC6  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>For the USBD_AddDriver() function description, refer to the: <a href="./../../docs/UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a>.</dd></dl>
<p>The emUSB-Device is provided in the form of pre-build libraries. The pre-build library is selected automatically based on configuration of Application project.</p>
<p>The emUSB-device has been already implemented the Target OS Interface for both RTOS and non-RTOS aware environments. The Target OS Interface for RTOS environment is implemented by FreeRTOS.</p>
<p>The hardware dependency files are present in export/Config directory, which consist of:</p><ul>
<li>One common file responsible for the debug message output</li>
<li>Device-specific files for the hardware configuration of each supported device family</li>
</ul>
<p>Also, the emUSB-Host/Device personality is present in the Device-configurator for simplify routine of configuration clocks and pins for USB IP block operation. The personality is a part of mtb-pdl-cat1 for CAT1A Devices Family.</p>
<h1><a class="anchor" id="section_emusb_device_quick_start"></a>
Quick Start</h1>
<p>To set up emUSB-Device for mouse and keyboard Human Interface Devices (HID), follow the below-described steps. These code snippets will move the mouse cursor left and right and print the "Hello world" message into the opened text editor. The current snippet is based on SEGGER sample application.</p>
<h2><a class="anchor" id="subsection_qsg_step1"></a>
STEP 1: Add the emUSB-Device middleware.</h2>
<ol type="1">
<li>Launch the ModusToolbox Library Manager, click Add Library button and select the emUSB-Device. This step is required only if the ModusToolbox IDE is used. Otherwise, ensure that the emUSB-Device middleware is included in your project. <div class="image">
<img src="emusb_device_lib_mngr.png" alt="emusb_device_lib_mngr.png"/>
</div>
 <dl class="section note"><dt>Note</dt><dd>To use the terminal output, add <a href="https://infineon.github.io/retarget-io/html/index.html"><b>retarget-io middleware </b></a> from the Library Manager. </dd>
<dd>
Add the FreeRTOS middleware into the Library Manager if you want to use the FreeRTOS.</dd></dl>
</li>
<li>Open Makefile of the project. Add USBD_BASE to the COMPONENTS section of the Makefile. <div class="image">
<img src="emusb_device_makefile.png" alt="emusb_device_makefile.png"/>
</div>
 <dl class="section note"><dt>Note</dt><dd>Add FREERTOS to the COMPONENTS section of the Makefile if you want to use FreeRTOS. <div class="image">
<img src="emusb_device_makefile_freertos.png" alt="emusb_device_makefile_freertos.png"/>
</div>
</dd></dl>
</li>
</ol>
<h2><a class="anchor" id="subsection_qsg_step2"></a>
STEP 2: Configure pins and clocks for emUSB-Device.</h2>
<ol type="1">
<li>Launch the ModusToolbox Device Configurator Tool and switch to the Peripherals tab (#1.1).</li>
<li>Enable the USB personality under Communication (#1.2) and select the emUSB-Host/Device 1.0 personality (#1.3).</li>
<li>Ensure that USB mode is Device (#1.4) and the Clock is connected to CLK_HF3 (#1.5). <div class="image">
<img src="emusb_device_peripherals_cfg.png" alt="emusb_device_peripherals_cfg.png"/>
</div>
</li>
<li><p class="startli">Switch to the System tab (#2.1).</p>
<dl class="section note"><dt>Note</dt><dd>The clocking system can be different between devices.</dd></dl>
</li>
<li>Check the IMO clock is enabled (#2.2). Select Trim with the USB.</li>
<li>If your device supports more than one PLL, select one. Enable the selected PLL and set a frequency of 48 MHz (#2.3). <dl class="section note"><dt>Note</dt><dd>Select the enabled source clock with accuracy +/-0.25% into the PATH_MUX section of the selected PLL (#2.4).</dd></dl>
</li>
<li>Select the CLK_HF3 USB clock (#2.5). Assign the source clock to the CLK_PATH connected to the configured previously PLL.</li>
<li>Select the CLK_HF0 USB clock (#2.6). Assign the source clock to the CLK_PATH connected to the PLL with the clock accuracy +/-0.25%. <dl class="section note"><dt>Note</dt><dd>You can use the PLL selected for CLK_HF3 or choose another one as it shown into the example (#2.7)</dd></dl>
</li>
<li>Select File-&gt;Save to generate initialization code. <div class="image">
<img src="emusb_device_system_cfg.png" alt="emusb_device_system_cfg.png"/>
</div>
</li>
<li>Also if the Power personality is enabled the System Idle Power Mode must be have Active or CPU sleep. <div class="image">
<img src="emusb_device_power_cfg.png" alt="emusb_device_power_cfg.png"/>
</div>
</li>
</ol>
<h2><a class="anchor" id="subsection_qsg_step3"></a>
STEP 3: Write the code in main.c.</h2>
<ol type="1">
<li>Include headers to get access to the emUSB drivers and retarget-io. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ctype.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;cybsp.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;cy_retarget_io.h&quot;</span></div><div class="line"><span class="comment">/* Include emUSB-Device headers */</span></div><div class="line"><span class="preprocessor">#include &quot;USB.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;USB_HID.h&quot;</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Include the following headers if you want to use FreeRTOS: <div class="fragment"><div class="line"><span class="comment">/* Include FreeRTOS headers */</span></div><div class="line"><span class="preprocessor">#include &quot;FreeRTOS.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;task.h&quot;</span></div></div><!-- fragment --> </dd>
<dd>
If you are working with CAT1A boards, include the following file: <br />
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cyhal.h&quot;</span></div></div><!-- fragment --></dd></dl>
</li>
<li>Add a structure prototype with the information about emUSB-Device. <div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> USB_DEVICE_INFO device_info = {</div><div class="line">    0x8765,                       <span class="comment">/* VendorId */</span></div><div class="line">    0x1116,                       <span class="comment">/* ProductId. Should be unique for this sample */</span></div><div class="line">    <span class="stringliteral">&quot;Vendor&quot;</span>,                     <span class="comment">/* VendorName */</span></div><div class="line">    <span class="stringliteral">&quot;HID mouse/keyboard sample&quot;</span>,  <span class="comment">/* ProductName */</span></div><div class="line">    <span class="stringliteral">&quot;12345678&quot;</span>                    <span class="comment">/* SerialNumber */</span></div><div class="line">};</div></div><!-- fragment --></li>
<li>Create a structure prototype for the keyboard data. <div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">    uint16_t key_code;</div><div class="line">    <span class="keywordtype">char</span>     key_char;</div><div class="line">} code_to_desc_t;</div></div><!-- fragment --></li>
<li>Initialize the table of the keyboard keys code and the keys descriptions. <div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span>  code_to_desc_t key_code_to_string_table[] = {</div><div class="line">    { 0x04, <span class="charliteral">&#39;a&#39;</span>},</div><div class="line">    { 0x05, <span class="charliteral">&#39;b&#39;</span>},</div><div class="line">    { 0x06, <span class="charliteral">&#39;c&#39;</span>},</div><div class="line">    { 0x07, <span class="charliteral">&#39;d&#39;</span>},</div><div class="line">    { 0x08, <span class="charliteral">&#39;e&#39;</span>},</div><div class="line">    { 0x09, <span class="charliteral">&#39;f&#39;</span>},</div><div class="line">    { 0x0A, <span class="charliteral">&#39;g&#39;</span>},</div><div class="line">    { 0x0B, <span class="charliteral">&#39;h&#39;</span>},</div><div class="line">    { 0x0C, <span class="charliteral">&#39;i&#39;</span>},</div><div class="line">    { 0x0D, <span class="charliteral">&#39;j&#39;</span>},</div><div class="line">    { 0x0E, <span class="charliteral">&#39;k&#39;</span>},</div><div class="line">    { 0x0F, <span class="charliteral">&#39;l&#39;</span>},</div><div class="line">    { 0x10, <span class="charliteral">&#39;m&#39;</span>},</div><div class="line">    { 0x11, <span class="charliteral">&#39;n&#39;</span>},</div><div class="line">    { 0x12, <span class="charliteral">&#39;o&#39;</span>},</div><div class="line">    { 0x13, <span class="charliteral">&#39;p&#39;</span>},</div><div class="line">    { 0x14, <span class="charliteral">&#39;q&#39;</span>},</div><div class="line">    { 0x15, <span class="charliteral">&#39;r&#39;</span>},</div><div class="line">    { 0x16, <span class="charliteral">&#39;s&#39;</span>},</div><div class="line">    { 0x17, <span class="charliteral">&#39;t&#39;</span>},</div><div class="line">    { 0x18, <span class="charliteral">&#39;u&#39;</span>},</div><div class="line">    { 0x19, <span class="charliteral">&#39;v&#39;</span>},</div><div class="line">    { 0x1A, <span class="charliteral">&#39;w&#39;</span>},</div><div class="line">    { 0x1B, <span class="charliteral">&#39;x&#39;</span>},</div><div class="line">    { 0x1C, <span class="charliteral">&#39;y&#39;</span>},</div><div class="line">    { 0x1D, <span class="charliteral">&#39;z&#39;</span>},</div><div class="line">    { 0x1E, <span class="charliteral">&#39;1&#39;</span>},</div><div class="line">    { 0x1F, <span class="charliteral">&#39;2&#39;</span>},</div><div class="line">    { 0x20, <span class="charliteral">&#39;3&#39;</span>},</div><div class="line">    { 0x21, <span class="charliteral">&#39;4&#39;</span>},</div><div class="line">    { 0x22, <span class="charliteral">&#39;5&#39;</span>},</div><div class="line">    { 0x23, <span class="charliteral">&#39;6&#39;</span>},</div><div class="line">    { 0x24, <span class="charliteral">&#39;7&#39;</span>},</div><div class="line">    { 0x25, <span class="charliteral">&#39;8&#39;</span>},</div><div class="line">    { 0x26, <span class="charliteral">&#39;9&#39;</span>},</div><div class="line">    { 0x27, <span class="charliteral">&#39;0&#39;</span>},</div><div class="line">    { 0x2C, <span class="charliteral">&#39; &#39;</span>},</div><div class="line">    { 0x37, <span class="charliteral">&#39;.&#39;</span>}</div><div class="line">};</div></div><!-- fragment --></li>
<li>Add the keyboard and mouse HID reports. These reports are generated according to HID spec and HID Usage Tables specification. <div class="fragment"><div class="line"><span class="keyword">const</span> uint8_t hid_report_keyboard[] =</div><div class="line">{</div><div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div><div class="line">    USB_HID_USAGE_PAGE_GENERIC_DESKTOP,</div><div class="line">    USB_HID_LOCAL_USAGE + 1,</div><div class="line">    USB_HID_USAGE_KEYBOARD,</div><div class="line">    USB_HID_MAIN_COLLECTION + 1,</div><div class="line">    USB_HID_COLLECTION_APPLICATION,</div><div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div><div class="line">    7,</div><div class="line">    USB_HID_LOCAL_USAGE_MINIMUM + 1,</div><div class="line">    224,</div><div class="line">    USB_HID_LOCAL_USAGE_MAXIMUM + 1,</div><div class="line">    231,</div><div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div><div class="line">    0,</div><div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div><div class="line">    1,</div><div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div><div class="line">    1,</div><div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div><div class="line">    8,</div><div class="line">    USB_HID_MAIN_INPUT + 1,</div><div class="line">    USB_HID_VARIABLE,</div><div class="line">    USB_HID_MAIN_INPUT + 1,</div><div class="line">    1,</div><div class="line">    USB_HID_LOCAL_USAGE_MINIMUM + 1,</div><div class="line">    0,</div><div class="line">    USB_HID_LOCAL_USAGE_MAXIMUM + 1,</div><div class="line">    101,</div><div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div><div class="line">    0,</div><div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div><div class="line">    101,</div><div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div><div class="line">    8,</div><div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div><div class="line">    6,</div><div class="line">    USB_HID_MAIN_INPUT + 1,</div><div class="line">    0,</div><div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div><div class="line">    USB_HID_USAGE_PAGE_LEDS,</div><div class="line">    USB_HID_LOCAL_USAGE_MINIMUM + 1,</div><div class="line">    1,</div><div class="line">    USB_HID_LOCAL_USAGE_MAXIMUM + 1,</div><div class="line">    5,</div><div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div><div class="line">    0,</div><div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div><div class="line">    1,</div><div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div><div class="line">    1,</div><div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div><div class="line">    5,</div><div class="line">    USB_HID_MAIN_OUTPUT + 1,</div><div class="line">    2,</div><div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div><div class="line">    3,</div><div class="line">    USB_HID_MAIN_OUTPUT + 1,</div><div class="line">    1,</div><div class="line">    USB_HID_MAIN_ENDCOLLECTION</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">const</span> uint8_t hid_report_mouse[] =</div><div class="line">{</div><div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div><div class="line">    USB_HID_USAGE_PAGE_GENERIC_DESKTOP,</div><div class="line">    USB_HID_LOCAL_USAGE + 1,</div><div class="line">    USB_HID_USAGE_MOUSE,</div><div class="line">    USB_HID_MAIN_COLLECTION + 1,</div><div class="line">    USB_HID_COLLECTION_APPLICATION,</div><div class="line">    USB_HID_LOCAL_USAGE + 1,</div><div class="line">    USB_HID_USAGE_POINTER,</div><div class="line">    USB_HID_MAIN_COLLECTION + 1,</div><div class="line">    USB_HID_COLLECTION_PHYSICAL,</div><div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div><div class="line">    USB_HID_USAGE_PAGE_BUTTON,</div><div class="line">    USB_HID_LOCAL_USAGE_MINIMUM + 1,</div><div class="line">    1,</div><div class="line">    USB_HID_LOCAL_USAGE_MAXIMUM + 1,</div><div class="line">    3,</div><div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div><div class="line">    0,</div><div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div><div class="line">    1,</div><div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div><div class="line">    3,</div><div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div><div class="line">    1,</div><div class="line">    USB_HID_MAIN_INPUT + 1,</div><div class="line">    USB_HID_VARIABLE, <span class="comment">/* 3 button bits */</span></div><div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div><div class="line">    1,</div><div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div><div class="line">    5,</div><div class="line">    USB_HID_MAIN_INPUT + 1,</div><div class="line">    USB_HID_CONSTANT, <span class="comment">/* 5 bit padding */</span></div><div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div><div class="line">    USB_HID_USAGE_PAGE_GENERIC_DESKTOP,</div><div class="line">    USB_HID_LOCAL_USAGE + 1,</div><div class="line">    USB_HID_USAGE_X,</div><div class="line">    USB_HID_LOCAL_USAGE + 1,</div><div class="line">    USB_HID_USAGE_Y,</div><div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div><div class="line">    (<span class="keywordtype">unsigned</span> char)-127,</div><div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div><div class="line">    127,</div><div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div><div class="line">    8,</div><div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div><div class="line">    2,</div><div class="line">    USB_HID_MAIN_INPUT + 1,</div><div class="line">    USB_HID_VARIABLE | USB_HID_RELATIVE,</div><div class="line">    USB_HID_MAIN_ENDCOLLECTION,</div><div class="line">    USB_HID_MAIN_ENDCOLLECTION</div><div class="line">};</div></div><!-- fragment --></li>
<li>Add the functions for adding the keyboard and the mouse to the USB stack. <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div><div class="line"><span class="comment">* Function Name: add_keyboard</span></div><div class="line"><span class="comment">********************************************************************************</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* Adds the HID keyboard device to the USB stack.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* \return Keyboard handler</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">*******************************************************************************/</span></div><div class="line"><span class="keyword">static</span> USB_HID_HANDLE add_keyboard(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    USB_HID_INIT_DATA init_data;</div><div class="line">    USB_ADD_EP_INFO   ep_int_in;</div><div class="line">    USB_HID_HANDLE    keyboard_handler;</div><div class="line"></div><div class="line">    <span class="comment">/* Sets the init_data elements with 0 */</span></div><div class="line">    memset(&amp;init_data, 0, <span class="keyword">sizeof</span>(init_data));</div><div class="line"></div><div class="line">    <span class="comment">/* Sets the flags of the not-used state */</span></div><div class="line">    ep_int_in.Flags = 0;</div><div class="line">    <span class="comment">/* Sets the IN-direction (Device to Host) */</span></div><div class="line">    ep_int_in.InDir = USB_DIR_IN;</div><div class="line">    <span class="comment">/* Sets the interval of 8 ms (125 us * 64) */</span></div><div class="line">    ep_int_in.Interval = 64;</div><div class="line">    <span class="comment">/* Sets the maximum packet size (64 for Interrupt) */</span></div><div class="line">    ep_int_in.MaxPacketSize = USB_HS_INT_MAX_PACKET_SIZE;</div><div class="line">    <span class="comment">/* Sets the endpoint type as Interrupt */</span></div><div class="line">    ep_int_in.TransferType = USB_TRANSFER_TYPE_INT;</div><div class="line">    <span class="comment">/* Initializes the endpoint handle data */</span></div><div class="line">    init_data.EPIn = USBD_AddEPEx(&amp;ep_int_in, NULL, 0);</div><div class="line">    <span class="comment">/* Gets the pointer to a report mouse descriptor */</span></div><div class="line">    init_data.pReport = hid_report_keyboard;</div><div class="line">    <span class="comment">/* Initializes the size of the HID report descriptor */</span></div><div class="line">    init_data.NumBytesReport = <span class="keyword">sizeof</span>(hid_report_keyboard);</div><div class="line">    <span class="comment">/* Adds an HID keyboard device to the USB interface */</span></div><div class="line">    keyboard_handler = USBD_HID_Add(&amp;init_data);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> keyboard_handler;</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div><div class="line"><span class="comment">* Function Name: add_mouse</span></div><div class="line"><span class="comment">********************************************************************************</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* Adds the HID mouse device to the USB stack.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* \return Mouse handler</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">*******************************************************************************/</span></div><div class="line"><span class="keyword">static</span> USB_HID_HANDLE add_mouse(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    USB_HID_INIT_DATA init_data;</div><div class="line">    USB_ADD_EP_INFO   ep_int_in;</div><div class="line">    USB_HID_HANDLE    mouse_handler;</div><div class="line"></div><div class="line">    <span class="comment">/* Sets the init_data elements to 0 value */</span></div><div class="line">    memset(&amp;init_data, 0, <span class="keyword">sizeof</span>(init_data));</div><div class="line"></div><div class="line">    <span class="comment">/* Sets the flags of the not-used state */</span></div><div class="line">    ep_int_in.Flags = 0;</div><div class="line">    <span class="comment">/* Sets the IN-direction (Device to Host) */</span></div><div class="line">    ep_int_in.InDir = USB_DIR_IN;</div><div class="line">    <span class="comment">/* Sets the interval of 8 ms (125 us * 64) */</span></div><div class="line">    ep_int_in.Interval = 64;</div><div class="line">    <span class="comment">/* Sets the maximum packet size (64 for Interrupt) */</span></div><div class="line">    ep_int_in.MaxPacketSize = USB_HS_INT_MAX_PACKET_SIZE;</div><div class="line">    <span class="comment">/* Sets the endpoint type as Interrupt */</span></div><div class="line">    ep_int_in.TransferType = USB_TRANSFER_TYPE_INT;</div><div class="line">    <span class="comment">/* Initializes the endpoint handle data */</span></div><div class="line">    init_data.EPIn = USBD_AddEPEx(&amp;ep_int_in, NULL, 0);</div><div class="line">    <span class="comment">/* Gets the pointer to a report mouse descriptor */</span></div><div class="line">    init_data.pReport = hid_report_mouse;</div><div class="line">    <span class="comment">/* Initializes the size of the HID report descriptor */</span></div><div class="line">    init_data.NumBytesReport = <span class="keyword">sizeof</span>(hid_report_mouse);</div><div class="line">    <span class="comment">/* Adds an HID mouse device to the USB interface */</span></div><div class="line">    mouse_handler = USBD_HID_Add(&amp;init_data);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> mouse_handler;</div><div class="line">}</div></div><!-- fragment --></li>
<li>Add the function for writing the keyboard data to the host. <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div><div class="line"><span class="comment">* Function Name: keyboard_send_text</span></div><div class="line"><span class="comment">********************************************************************************</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* Writes the keyboard data to the host.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* \param keyboard_handler  The HID keyboard device handler.</span></div><div class="line"><span class="comment">* \param keyboard_text  The text data to send to the host.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">*******************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> keyboard_send_text(USB_HID_HANDLE keyboard_handler, <span class="keyword">const</span> <span class="keywordtype">char</span>* keyboard_text)</div><div class="line">{</div><div class="line">    uint8_t  char_arr[8];</div><div class="line">    <span class="keywordtype">char</span>     char_temp;</div><div class="line">    uint32_t i;</div><div class="line">    uint32_t j;</div><div class="line">    uint32_t key_code_to_string_table_size;</div><div class="line"></div><div class="line">    key_code_to_string_table_size = ((<span class="keyword">sizeof</span>(key_code_to_string_table)) / (<span class="keyword">sizeof</span>(key_code_to_string_table[0])));</div><div class="line"></div><div class="line">    <span class="comment">/* Sets all char_arr elements with 0 */</span></div><div class="line">    memset(char_arr, 0, <span class="keyword">sizeof</span>(char_arr));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (i = 0; keyboard_text[i] != 0; i++)</div><div class="line">    {</div><div class="line">        <span class="comment">/* A character is uppercase if its hex value is less than 0x61 (&#39;a&#39;)</span></div><div class="line"><span class="comment">         * and greater or equal to 0x41 (&#39;A&#39;), therefore we set the LeftShiftUp</span></div><div class="line"><span class="comment">         * bit for those characters</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keywordflow">if</span> (keyboard_text[i] &lt; 0x61 &amp;&amp; keyboard_text[i] &gt;= 0x41)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Disables LeftShiftUp */</span></div><div class="line">            char_arr[0] = (1 &lt;&lt; 1);</div><div class="line">            <span class="comment">/* Converts the character to lowercase */</span></div><div class="line">            char_temp = tolower((<span class="keywordtype">int</span>)keyboard_text[i]);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            char_temp = keyboard_text[i];</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (j = 0; j &lt; key_code_to_string_table_size; j++)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (key_code_to_string_table[j].key_char == char_temp)</div><div class="line">            {</div><div class="line">                <span class="comment">/* Gets the character code */</span></div><div class="line">                char_arr[2] = key_code_to_string_table[j].key_code;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Writes data to the host */</span></div><div class="line">        USBD_HID_Write(keyboard_handler, <span class="comment">/* The HID instance */</span></div><div class="line">            &amp;char_arr[0],                <span class="comment">/* The pointer to the data array to send */</span></div><div class="line">            8u,                          <span class="comment">/* The number of bytes to send */</span></div><div class="line">            0);                          <span class="comment">/* The Timeout in milliseconds */</span></div><div class="line"></div><div class="line">        <span class="comment">/* Sets all char_arr elements with 0 */</span></div><div class="line">        memset(char_arr, 0, <span class="keyword">sizeof</span>(char_arr));</div><div class="line"></div><div class="line">        <span class="comment">/* Send a 0 field packet to tell the host that the key has been released */</span></div><div class="line">        USBD_HID_Write(keyboard_handler, <span class="comment">/* The HID instance */</span></div><div class="line">            &amp;char_arr[0],                <span class="comment">/* The pointer to the data array to send */</span></div><div class="line">            8u,                          <span class="comment">/* The number of bytes to send */</span></div><div class="line">            0);                          <span class="comment">/* The Timeout in milliseconds */</span></div><div class="line"></div><div class="line">        <span class="comment">/* The delay is 50 milliseconds */</span></div><div class="line">        USB_OS_Delay(50);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></li>
<li>Add the function for writing the mouse movements data to the host. <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div><div class="line"><span class="comment">* Function Name: mouse_moves</span></div><div class="line"><span class="comment">********************************************************************************</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* Writes the mouse movements data to the host.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* \param mouse_handler  The HID mouse device handler.</span></div><div class="line"><span class="comment">* \param mouse_move gets data about the mouse movement.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">*******************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> mouse_moves(USB_HID_HANDLE mouse_handler, int8_t mouse_move)</div><div class="line">{</div><div class="line">    uint8_t move_arr[3];</div><div class="line"></div><div class="line">    <span class="comment">/* Sets all move_arr elements with 0 */</span></div><div class="line">    memset(move_arr, 0, <span class="keyword">sizeof</span>(move_arr));</div><div class="line"></div><div class="line">    <span class="comment">/* Gets the mouse movement value */</span></div><div class="line">    move_arr[1] = (uint8_t)mouse_move;</div><div class="line"></div><div class="line">    <span class="comment">/* Writes data to the host */</span></div><div class="line">    USBD_HID_Write(mouse_handler, <span class="comment">/* The HID instance */</span></div><div class="line">        &amp;move_arr[0],             <span class="comment">/* The pointer to the data array to send */</span></div><div class="line">        3u,                       <span class="comment">/* The number of bytes to send */</span></div><div class="line">        0);                       <span class="comment">/* The Timeout in milliseconds */</span></div><div class="line"></div><div class="line">    USB_OS_Delay(1000);</div><div class="line">}</div></div><!-- fragment --></li>
<li>Create the main_task() function <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div><div class="line"><span class="comment">* Function Name: main_task</span></div><div class="line"><span class="comment">********************************************************************************</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* Initializes the emUSB-Device stack.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* \param arg  is not used in this function but required for using FreeRTOS.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">*******************************************************************************/</span></div><div class="line"><span class="keywordtype">void</span> main_task(<span class="keywordtype">void</span>* arg)</div><div class="line">{</div><div class="line">    (void)arg;</div><div class="line"></div><div class="line">    <span class="comment">/* Mouse movement values */</span></div><div class="line">    int8_t mouse_move_left = -75;</div><div class="line">    int8_t mouse_move_right = 75;</div><div class="line"></div><div class="line">    <span class="comment">/* The output text from the keyboard */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* keyboard_text = <span class="stringliteral">&quot;Hello world! &quot;</span>;</div><div class="line"></div><div class="line">    USB_HID_HANDLE mouse_handler;</div><div class="line">    USB_HID_HANDLE keyboard_handler;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialization of emUSB-Device */</span></div><div class="line">    USBD_Init();</div><div class="line"></div><div class="line">    <span class="comment">/* Adds the HID keyboard device to the USB stack */</span></div><div class="line">    keyboard_handler = add_keyboard();</div><div class="line">    <span class="comment">/* Adds the HID mouse device to the USB stack */</span></div><div class="line">    mouse_handler = add_mouse();</div><div class="line"></div><div class="line">    <span class="comment">/* Sets information used during the device enumeration */</span></div><div class="line">    USBD_SetDeviceInfo(&amp;device_info);</div><div class="line">    <span class="comment">/* Starts emUSB-Device */</span></div><div class="line">    USBD_Start();</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Waits for configuration */</span></div><div class="line">        <span class="keywordflow">while</span> ((USBD_GetState() &amp; (USB_STAT_CONFIGURED | USB_STAT_SUSPENDED)) != USB_STAT_CONFIGURED)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Do something to indicate waiting for configuration */</span></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">/* Moves the mouse cursor left and right */</span></div><div class="line">        mouse_moves(mouse_handler, mouse_move_left);</div><div class="line">        mouse_moves(mouse_handler, mouse_move_right);</div><div class="line">        <span class="comment">/* Prints the text */</span></div><div class="line">        keyboard_send_text(keyboard_handler, keyboard_text);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></li>
<li>Initialize retarget-io in main() to use the debug UART port. <dl class="section note"><dt>Note</dt><dd>If you are working with CAT1A boards, use the following code to configure retarget_io: <div class="fragment"><div class="line">    cy_retarget_io_init(CYBSP_DEBUG_UART_TX, CYBSP_DEBUG_UART_RX, CY_RETARGET_IO_BAUDRATE);</div></div><!-- fragment --></dd></dl>
</li>
<li><p class="startli">Call main_task():</p>
<p class="startli"><b> For non-RTOS environments:</b></p>
<p class="startli">Call the main_task() into the main() function. </p><div class="fragment"><div class="line">    main_task(NULL);</div></div><!-- fragment --><p> <b> For RTOS environments:</b></p>
<p class="startli">Create a FreeRTOS task with main_task() using xTaskCreate and start the task scheduler instead of calling main_task(): </p><div class="fragment"><div class="line">    <span class="comment">/* Creates a FreeRTOS task of the main_task() function */</span></div><div class="line">    xTaskCreate(main_task, <span class="stringliteral">&quot;main_task&quot;</span>, 500U, NULL, configMAX_PRIORITIES - 6, NULL);</div><div class="line">    vTaskStartScheduler();</div></div><!-- fragment --> </li>
</ol>
<h2><a class="anchor" id="subsection_qsg_step5"></a>
STEP 4: Check the emUSB-Device workability.</h2>
<ol type="1">
<li>Build and program your project.</li>
<li>Connect the USB-Device connector to the PC host.</li>
<li>Observe the mouse cursor move and print the "Hello world" message into the text editor.</li>
</ol>
<h1><a class="anchor" id="section_emusb_device_config_cons"></a>
Configuration Considerations</h1>
<p>This section explains the details of the emUSB-Device configuration.</p>
<h2><a class="anchor" id="section_emusb_device_hw_dep_conf"></a>
Hardware-dependent Configuration</h2>
<p>The hardware resources (Pins, clocks, interrupts) required for USB must be configured before the start of USB operation before calling USBD_Init() or in USBD_X_Config(). USB pins (D+ and D-) and USB clocks can be configured by a personality in the Device Configurator or by PDL/HAL drivers. Interrupts must be configured in the USBD_X_Config() function. Also, USBD_X_EnableInterrupt() and USBD_X_DisableInterrupt() must be implemented when the USBD_OS_USE_USBD_X_INTERRUPT compile time option is enabled.</p>
<p>The implementation template of USBD_X_Config(), USBD_X_EnableInterrupt() and USBD_X_DisableInterrupt() is provided for each device category in the Config directory under COMPONENT_CATx. This template is automatically copied into your project when middleware is added to project. This template does not include the configuration of clock and pins required for USB operation.</p>
<p>For details on Hardware Dependent Configuration, refer to the - <a href="./../../docs/UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a>.</p>
<h3><a class="anchor" id="section_emusb_device_hw_dep_conf_pins"></a>
USB Pins Configuration</h3>
<p>The D+ and D- pins must be configured for USB operation. The emUSB-Host/Device personality in the Device Configurator allows for easy configuration of the pins. Otherwise, the pins can be configured manually by PDL APIs.</p>
<p><b> CAT1A Devices Family </b></p>
<p>The following snippet initializes GPIO pins for USB operation by <a href="https://github.com/Infineon/mtb-pdl-cat1"><b>mtb-pdl-cat1 APIs</b></a>.</p>
<div class="fragment"><div class="line">    Cy_GPIO_Pin_FastInit(USBDP_PORT, USBDP_PIN, CY_GPIO_DM_ANALOG, 0U, USBDP_GPIO);</div><div class="line">    Cy_GPIO_Pin_FastInit(USBDM_PORT, USBDM_PIN, CY_GPIO_DM_ANALOG, 0U, USBDM_GPIO);</div></div><!-- fragment --><h3><a class="anchor" id="section_emusb_device_hw_dep_conf_clock"></a>
USB Clock Configuration</h3>
<p>The USB 2.0 specification defines the required bit rate accuracy for the device in section 7.1.11. Ensure that the clock sources for USB meet the requirements.</p>
<p>The emUSB-Host/Device personality in the Device Configurator allows for easy configuration of the clocks for USB operation and also check if the clocks meet the requirements. Otherwise, the clocks can be configured manually by PDL/HAL APIs.</p>
<p><b> CAT1A Devices Family </b></p>
<p>The USB device requires two clocks for operation:</p><ul>
<li>Clock the main clock at 48 MHz. Typically, the main clock is CLK_HF3 output signal, but refer to the device datasheet to identify the clock source for USB for a specific device.</li>
<li>Clock the Clock (Bus Reset) at 100 kHz. Typically, Clock (Bus Reset) is connected to CLK_PERI through peripheral clock dividers but refer to the device datasheet to identify the Clock (Bus Reset) source for USB for a specific device.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Ensure that the clock sources for USB meet the requirements.</dd></dl>
<h3><a class="anchor" id="section_emusb_device_hw_dep_conf_int"></a>
USB Interrupt Configuration</h3>
<p>The interrupt is mandatory for the emUSB-Device Middleware operation. The interrupt priority selection is a part of Application level - the interrupt priority selected in the template files is not suitable for real project. For USB recommended setting the interrupt priority as high as possible.</p>
<p><b> CAT1A Devices Family </b></p>
<p>emUSB-Device uses only one interrupt source from the three available in the IP USB block - usb_interrupt_med_IRQn. The emUSB-Device code can be executed on CM4 and CM0+ cores. For CM0+, the interrupt source of the USB IP block can be connected to one of CM0+ IRQs. Refer to the device datasheet and <a href="https://infineon.github.io/mtb-pdl-cat1/pdl_api_reference_manual/html/group__group__sysint.html"><b>SysInt (System Interrupt) Driver documentation</b></a> to find the available IRQs for CM0+.</p>
<p>The following code snippet shows the interrupt configuration for both CM4 and CM0+ cores.</p>
<dl class="section note"><dt>Note</dt><dd>The number of CM0+ interrupt vectors is different for different devices, so, this code snippet may not be suitable for all devices.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">/* Define the interrupt source */</span></div><div class="line"><span class="preprocessor">#if (COMPONENT_CM0P)</span></div><div class="line"><span class="comment">/* The number of CM0+ interrupt vectors is different for different devices,</span></div><div class="line"><span class="comment"> * so, change the following macro for your selected device.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#define USBD_INTERRUPT_NUM                      (NvicMux7_IRQn)</span></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#define USBD_INTERRUPT_NUM                      (usb_interrupt_med_IRQn)</span></div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* #if (COMPONENT_CM0P) */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line"><span class="comment">/* Define the interrupt priority */</span></div><div class="line"><span class="preprocessor">#define USBD_ISR_PRIO                           (3U)</span></div><div class="line"></div><div class="line"><span class="comment">/* This function should be register as a callback in USBD_SetISREnableFunc(). */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> enable_isr(USB_ISR_HANDLER * pfISRHandler)</div><div class="line">{</div><div class="line">    <span class="comment">/* Install interrupt service routine */</span></div><div class="line">    cy_rslt_t result;</div><div class="line">    result = cyhal_system_set_isr(USBD_INTERRUPT_NUM, usb_interrupt_med_IRQn, USBD_ISR_PRIO, pfISRHandler);</div><div class="line">    CY_ASSERT(CY_RSLT_SUCCESS == result);</div><div class="line">    (void) result; <span class="comment">/* To avoid the compiler warning in Release mode */</span></div><div class="line"></div><div class="line">    NVIC_EnableIRQ(USBD_INTERRUPT_NUM);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="section_emusb_device_debug_mes_out"></a>
Debug Message Output</h2>
<p>The debug builds of emUSB-Device allow using the debug message outputs. The template implementation of the message output functions is in export/Config/usbd_config_io.c file. Copy this template manually into your project and modify if required. By default, <a href="https://github.com/Infineon/retarget-io"><b>retarget-io</b></a> is used for the message output, but message outputs can be redefined to any suitable output way.</p>
<p>For details on Hardware Debug Message Output, refer to the - <a href="./../../docs/UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> Debugging chapter.</p>
<dl class="section note"><dt>Note</dt><dd>The retarget-io middleware must be configured outside of the emUSB-Device middleware for the message output. Refer to the <a href="https://github.com/Infineon/retarget-io#quick-start"><b>retarget-io Quick Start</b></a>.</dd>
<dd>
The retarget-io does not send the debug message from the interrupt in RTOS aware environments.</dd></dl>
<h2><a class="anchor" id="section_emusb_device_low_power"></a>
Low Power Support</h2>
<p>The suspended device must limit the current consumption from VBUS to 0.5 mA. Therefore, put the device into low-power mode to consume less current. To prepare emUSB-Device for entering Low-power mode and restore after, refer to the - <a href="./../../docs/UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> Low power mode chapter.</p>
<dl class="section note"><dt>Note</dt><dd>Preparing the USB for Low-power mode and detecting the Suspend condition are significantly different among devices. Pay attention to the following explanation for required devices.</dd></dl>
<p><b> CAT1A Devices Family </b></p>
<p>The two specific functions are provided for detecting Suspend condition and restoring emUSB-Device after Deep Sleep - USB_DRIVER_Cypress_PSoC6_SysTick() and USB_DRIVER_Cypress_PSoC6_Resume(). The application must call USB_DRIVER_Cypress_PSoC6_SysTick() every millisecond in order to get suspend events handled. The USB_DRIVER_Cypress_PSoC6_Resume() function must be called after waking up from Deep Sleep Low-power mode. For more details about these functions refer to the <a href="./../../docs/UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> PSoC6 driver chapter.</p>
<dl class="section note"><dt>Note</dt><dd>After waking up from Deep Sleep, USBD_GetState() can returns the Suspend status for some time. Wait up to 10 milliseconds and then check the USB status with USBD_GetState() because USB_DRIVER_Cypress_PSoC6_SysTick() requires some time for identifying the Resume condition.</dd></dl>
<p>The USB IP block is disabled during Deep Sleep Low-power mode. So, configure the falling edge interrupt on the D+ pin (before entering Deep Sleep) to exit Low-power mode when the Host drivers resume. The interrupt on the D+ pin wakes up the device from Low-power mode when the Host drivers resume.</p>
<dl class="section note"><dt>Note</dt><dd>The Remote Wake up functionality is not supported by the PSoC 6 driver.</dd></dl>
<h2><a class="anchor" id="section_emusb_device_pick_lib"></a>
Picking an emUSB-Device Library Variant</h2>
<p>The Middleware provides emUSB-Device as pre-build libraries. The pre-build libraries are selected automatically based on configurations of Makefile configurations. The table below shows the availability of the configuration options.</p>
<table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Make Variable </th></tr>
<tr>
<td>Device family </td><td>CAT1A </td><td>DEVICE_COMPONENTS  </td></tr>
<tr>
<td>Build configuration </td><td>Debug, Release </td><td>CONFIG  </td></tr>
<tr>
<td>Core </td><td>CM0P, CM4 </td><td>CORE  </td></tr>
<tr>
<td>Floating point </td><td>hardfp, softfp </td><td>VFP_SELECT  </td></tr>
<tr>
<td>Toolchain </td><td>GCC_ARM, IAR, ARM </td><td>TOOLCHAIN  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Typically, the device family and core are selected in BSP Makefile.</dd>
<dd>
CM0P supports only softfp.</dd></dl>
<p>The header file USBD_ConfDefaults.h under the USBD directory contains common configuration used in the libraries generation. Similarly, USBD_Conf.h under each COMPONENT_&lt;Device family&gt;/CONFIG_&lt; Build configuration&gt; directory contains configuration specific to the set of library variants.</p>
<h2><a class="anchor" id="section_emusb_device_use_in_rtos"></a>
Using emUSB-Device in an RTOS Environment</h2>
<p>The emUSB-device has been already implemented the Target OS Interface for both RTOS and non-RTOS aware environments. Selecting the OS layer implementation is automatic based on the <em>RTOS_AWARE</em> component. To inform the emUSB-Device that an RTOS environment is being used, set the <em>RTOS_AWARE</em> component (<em>COMPONENTS+=RTOS_AWARE</em>).</p>
<p>For the RTOS environment, the OS layer uses the <a href="https://github.com/Infineon/freertos"><b>FreeRTOS</b></a> library.</p>
<p>Specific implementation of Target OS Interface: </p><ul>
<li>
USB_OS_DecRI() and USB_OS_IncDI() have only alternate implementation because the USBD_OS_USE_USBD_X_INTERRUPT compile time option is enabled. Alternate implementation is more effective compared to the standard one because it allows disabling/enabling USB interrupts only before entering/exiting the critical section for emUSB-device.  </li>
<li>
<p class="startli">For non-RTOS environments, USB_OS_GetTickCnt() configures one instance of the timer by <code>Timer (Timer/Counter)</code> Driver of HAL library for returning the current system time in milliseconds. The timer is started by initializing the emUSB-Device middleware. USB_OS_GetTickCnt() own implementation can be provided due to: </p><ul>
<li>
The optimization of handling the ISR routine (the timer generates an interrupt every 1 millisecond);  </li>
<li>
Providing more reliable implementation (the timer value reloads every 49 days, 17 hours, 2 mins, 47.296 seconds);  </li>
<li>
The optimization of the HW resources usage (one instance of the TCPWM counter or similar HW resources, which can be used by <code>Timer (Timer/Counter)</code> Driver);  </li>
</ul>
<p>To do that, set the USBD_NORTOS_TICKCNT_ENABLE macro value to zero in Makefile file.</p>
<dl class="section note"><dt>Note</dt><dd><b>For CAT1A and devices:</b> The own implementation of USB_OS_GetTickCnt() must be provided if the application uses the transit into Deep Sleep or Hibernate low-power modes.  </dd></dl>
</li>
<li>
For Free-RTOS, USB tasks priority must be lower than the priority of RTOS daemon tasks (also known as timer service tasks). The RTOS daemon task priority is defined in configTIMER_TASK_PRIORITY.  </li>
</ul>
<p>For details on Target OS Interface, refer to the - <a href="./../../docs/UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> Target OS Interface chapter.</p>
<h1><a class="anchor" id="section_emusb_device_package_str"></a>
emUSB-Device Package Structure</h1>
<p>The Middleware structure:</p><ul>
<li><b>export/Config:</b> Contains sample configuration files for hardware-specific configuration.</li>
<li><b>OS:</b> Contains the OS layer implementation.</li>
<li><b>USBD:</b> Contains a set of pre-build emUSB-Device libraries for different configurations of user applications (Device family, Build configuration, Core, Floating point, Toolchain), and a set of header files.</li>
<li><b>docs:</b> Contains the API Reference Guide, SEGGER-provided emUSB-Device User Guide &amp; Reference Manual and other supporting documentation.</li>
</ul>
<h1><a class="anchor" id="section_emusb_device_changelog"></a>
Changelog</h1>
<p>Note that the emUSB-Device Middleware by Infineon and emUSB-Device stack by Segger have different versions</p>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>1.0.1 </td><td>Updating the LICENSE file </td><td></td></tr>
<tr>
<td>1.0.0 </td><td>Initial release of emUSB-Device stack 3.52.2 </td><td></td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>emusb-device</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
