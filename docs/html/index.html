<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>emusb-device</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">emusb-device</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">SEGGER emUSB-Device for ModusToolbox User Guide </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a href="https://www.segger.com/products/connectivity/emusb-device/"><b>emUSB-Device</b></a> enables easy integration of USB functionality into an embedded system.Multiple standard classes are provided that allow embedded systems to behave as standard USB devices and communicate with any host like Windows, Linux and Mac systems. Infineon has licensed emUSB-Device from SEGGER and offers it for free to its customers. This middleware library provides emUSB-Device in the form of pre-build libraries.</p>
<p ><b>Features:</b></p><ul>
<li>High performance</li>
<li>Can be used with or without an RTOS</li>
<li>Easy to use</li>
<li>Easy to port</li>
<li>No custom USB host driver necessary</li>
</ul>
<p ><b>Supported USB Device Classes:</b></p><ul>
<li>Audio</li>
<li>Legacy Audio V1 device class</li>
<li>Bulk communication</li>
<li>Smart Card Device Class (CCID)</li>
<li>Communication Device Class (CDC)</li>
<li>Human Interface Device Class (HID)</li>
<li>Mass Storage Device Class (MSD)</li>
<li>Media Transfer Protocol Class (MTP)</li>
<li>Printer Class</li>
<li>Virtual Mass Storage Component (VirtualMSD)</li>
<li>Vendor Specific Class (VSC)</li>
</ul>
<p ><b>Device families supported by the Middleware:</b></p><ul>
<li>CAT1A</li>
<li>CAT3</li>
</ul>
<h1><a class="anchor" id="section_emusb_device_general"></a>
General Description</h1>
<p >This manual provides only the basic concepts of emUSB-Device and integration specifics of the emUSB-Device into ModusToolbox flow. For a detail description of the emUSB-Device features, implementation, and APIs, refer to: <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a>.</p>
<p ><a class="el" href="index.html#section_emusb_device_quick_start">Quick Start</a> is available in this API Reference Guide.</p>
<p ><b>emUSB-Device consists of the following layers:</b></p><ul>
<li>The driver for hardware access</li>
<li>The emUSB-Device core</li>
<li>The USB class driver or the bulk communication component</li>
</ul>
<p >emUSB-Device core and the USB class drivers are device-independent, while the driver for hardware access is applicable only for one device family. The driver is selected in the USBD_X_Config() function, the template of implementation of USBD_X_Config() is in the export/Config folder.</p>
<p >The drivers for emUSB-Device can support not all available features and may need to be configured in a special manners, refer to the: <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> Device driver specifics chapter.</p>
<p ><b>Supported Drivers by the Device family</b></p>
<table class="doxtable">
<tr>
<th>Device family</th><th>Drivers</th><th>Pointer to the driver API structure </th></tr>
<tr>
<td>CAT1A </td><td>Cypress PSoC 6 driver </td><td><ul>
<li>USB_Driver_Cypress_PSoC6</li>
<li>USB_Driver_Cypress_PSoC6_DMA   </li>
</ul>
</td></tr>
<tr>
<td rowspan="2">CAT3 </td><td>Synopsys DWC2 driver (slave mode)  </td><td><ul>
<li>USB_Driver_Infineon_XMC45xx</li>
<li>USB_Driver_Infineon_XMC45xx_DynMem   </li>
</ul>
</td></tr>
<tr>
<td>Synopsys DWC2 driver (DMA mode)  </td><td>USB_Driver_Infineon_XMC45xx_DMA   </td></tr>
</table>
<p >For CAT3 device, the DMA engine of USB IP block does not have access to all SRAM regions. Check Reference Manual for CAT3 device for more information. As a result the memory pool for USB_Driver_Infineon_XMC45xx_DMA driver must be placed only to SRAM region with DMA access. Typically linker script provided with mtb-xmclib-cat3 defines special region - USB_RAM. You can place memory pool to USB_RAM by the next approach: <b>CY_SECTION("USB_RAM") __USED static uint32_t mem_pool[512]</b>. Also it is compulsory to register appropriate callback by USBD_SetCheckAddress(). This callback should check if an address can be used for DMA transfers. You can use the next variables from linker script to determine the borders of the SRAM region: <b>USB_RAM_start, USB_RAM_end</b>. The example of driver configuration is provided in usbd_config.c file.</p>
<dl class="section note"><dt>Note</dt><dd>For the USBD_AddDriver() function description, refer to the: <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a>.</dd></dl>
<p>The emUSB-Device is provided in the form of pre-build libraries. The pre-build library is selected automatically based on configuration of Application project.</p>
<p >The emUSB-device has been already implemented the Target OS Interface for both RTOS and non-RTOS aware environments. The Target OS Interface for RTOS environment is implemented by abstraction-rtos, so this Middleware can be used with any RTOSes supported by abstraction-rtos.</p>
<p >The hardware dependency files are present in export/Config directory, which consist of:</p><ul>
<li>One common file responsible for the debug message output</li>
<li>Device-specific files for the hardware configuration of each supported device family</li>
</ul>
<p >Also, the emUSB-Host/Device personality is present in the Device-configurator for simplify routine of configuration clocks and pins for USB IP block operation. The personality is a part of mtb-pdl-cat1 for CAT1A devices and mtb-xmclib-cat3 for CAT3 libraries.</p>
<h1><a class="anchor" id="section_emusb_device_quick_start"></a>
Quick Start</h1>
<p >To set up emUSB-Device for mouse and keyboard Human Interface Devices (HID), follow the below-described steps. These code snippets will move the mouse cursor left and right and print the "Hello world" message into the opened text editor. The current snippet is based on SEGGER sample application.</p>
<h2><a class="anchor" id="subsection_qsg_step1"></a>
STEP 1: Add the emUSB-Device middleware.</h2>
<ol type="1">
<li>Launch the ModusToolbox Library Manager, click Add Library button and select the emUSB-Device. This step is required only if the ModusToolbox IDE is used. Otherwise, ensure that the emUSB-Device middleware is included in your project. <div class="image">
<img src="emusb_device_lib_mngr.png" alt=""/>
</div>
 <dl class="section note"><dt>Note</dt><dd>To use the terminal output, add <a href="https://infineon.github.io/retarget-io/html/index.html"><b>retarget-io middleware </b></a> from the Library Manager. </dd>
<dd>
Add the FreeRTOS middleware into the Library Manager if you want to use the FreeRTOS.</dd></dl>
</li>
<li>Open Makefile of the project. Add USBD_BASE to the COMPONENTS section of the Makefile. <div class="image">
<img src="emusb_device_makefile.png" alt=""/>
</div>
 <dl class="section note"><dt>Note</dt><dd>Add FREERTOS and RTOS_AWARE to the COMPONENTS section of the Makefile if you want to use FreeRTOS. <div class="image">
<img src="emusb_device_makefile_freertos.png" alt=""/>
</div>
</dd></dl>
</li>
</ol>
<h2><a class="anchor" id="subsection_qsg_step2"></a>
STEP 2: Configure pins and clocks for emUSB-Device.</h2>
<p ><b>CAT1A Devices:</b></p>
<ol type="1">
<li>Launch the ModusToolbox Device Configurator and switch to the Peripherals tab (#1.1).</li>
<li>Enable the USB personality under Communication (#1.2) and select the emUSB-Host/Device personality (#1.3).</li>
<li>Ensure that USB mode is Device (#1.4) and the Clock is connected to CLK_HF3 (#1.5). <div class="image">
<img src="cat1a_emusb_device_peripherals_cfg.png" alt=""/>
</div>
</li>
<li><p class="startli">Switch to the System tab (#2.1).</p>
<dl class="section note"><dt>Note</dt><dd>The clocking system can be different between devices.</dd></dl>
</li>
<li>Check the IMO clock is enabled (#2.2). Select Trim with the USB.</li>
<li>If your device supports more than one PLL, select one. Enable the selected PLL and set a frequency of 48 MHz (#2.3). <dl class="section note"><dt>Note</dt><dd>Select the enabled source clock with accuracy +/-0.25% into the PATH_MUX section of the selected PLL (#2.4).</dd></dl>
</li>
<li>Select the CLK_HF3 USB clock (#2.5). Assign the source clock to the CLK_PATH connected to the configured previously PLL.</li>
<li>Select the CLK_HF0 USB clock (#2.6). Assign the source clock to the CLK_PATH connected to the PLL with the clock accuracy +/-0.25%. <dl class="section note"><dt>Note</dt><dd>You can use the PLL selected for CLK_HF3 or choose another one as it shown into the example (#2.7) <div class="image">
<img src="cat1a_emusb_device_system_cfg.png" alt=""/>
</div>
</dd></dl>
</li>
<li>If the Power personality is enabled, the System Idle Power Mode must be Active or CPU sleep. <div class="image">
<img src="cat1a_emusb_device_power_cfg.png" alt=""/>
</div>
</li>
<li>Select File-&gt;Save to generate initialization code.</li>
</ol>
<p ><b>CAT3 Devices:</b></p>
<ol type="1">
<li>Launch the ModusToolbox Device Configurator Tool and switch to the Peripherals tab (#1.1).</li>
<li>Enable the USB personality under Communication (#1.2).</li>
<li>Select the USB mode as Device (#1.3).</li>
<li>If you want to create a non-RTOS emUSB application, you should configure the emUSB OS Timer personality by selecting CCU4 source (#1.4) and configure the CCU4 Slice as the <em>emUSB OS Timer</em> personality (#1.5). Check the <em>CCU for OS</em> checkbox (#1.6) and select the appropriate emUSB OS Timer CCU Resource (#1.7). <div class="image">
<img src="cat3_emusb_device_peripherals_cfg.png" alt=""/>
</div>
</li>
<li>Follow the instructions in the bottom window to set up the clock source for USB. The USB clock source configuration must look like the configuration on the image below. <div class="image">
<img src="cat3_emusb_device_system_cfg.png" alt=""/>
</div>
 <dl class="section note"><dt>Note</dt><dd>You can also use <em>System PLL</em> instead <em>USB PLL</em> as a source.</dd>
<dd>
Recommended: set the highest frequency of <em>System PLL Clock -&gt; CPU Clock</em> for proper work of USB functionality.</dd></dl>
</li>
<li>Select File-&gt;Save to generate initialization code.</li>
</ol>
<h2><a class="anchor" id="subsection_qsg_step3"></a>
STEP 3: Write the code in main.c.</h2>
<ol type="1">
<li>Include headers to get access to the emUSB-Device functions and retarget-io. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ctype.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cybsp.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;cy_retarget_io.h&quot;</span></div>
<div class="line"><span class="comment">/* Include emUSB-Device headers */</span></div>
<div class="line"><span class="preprocessor">#include &quot;USB.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;USB_HID.h&quot;</span></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Include the following headers if you want to use FreeRTOS: <div class="fragment"><div class="line"><span class="comment">/* Include FreeRTOS headers */</span></div>
<div class="line"><span class="preprocessor">#include &quot;FreeRTOS.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;task.h&quot;</span></div>
</div><!-- fragment --></dd></dl>
</li>
<li>Add a structure prototype with the information about emUSB-Device. <div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> USB_DEVICE_INFO device_info = {</div>
<div class="line">    0x8765,                       <span class="comment">/* VendorId */</span></div>
<div class="line">    0x1116,                       <span class="comment">/* ProductId. Should be unique for this sample */</span></div>
<div class="line">    <span class="stringliteral">&quot;Vendor&quot;</span>,                     <span class="comment">/* VendorName */</span></div>
<div class="line">    <span class="stringliteral">&quot;HID mouse/keyboard sample&quot;</span>,  <span class="comment">/* ProductName */</span></div>
<div class="line">    <span class="stringliteral">&quot;12345678&quot;</span>                    <span class="comment">/* SerialNumber */</span></div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li>Create a structure prototype for the keyboard data. <div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    uint16_t key_code;</div>
<div class="line">    <span class="keywordtype">char</span>     key_char;</div>
<div class="line">} code_to_desc_t;</div>
</div><!-- fragment --></li>
<li>Initialize the table of the keyboard keys code and the keys descriptions. <div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span>  code_to_desc_t key_code_to_string_table[] = {</div>
<div class="line">    { 0x04, <span class="charliteral">&#39;a&#39;</span>},</div>
<div class="line">    { 0x05, <span class="charliteral">&#39;b&#39;</span>},</div>
<div class="line">    { 0x06, <span class="charliteral">&#39;c&#39;</span>},</div>
<div class="line">    { 0x07, <span class="charliteral">&#39;d&#39;</span>},</div>
<div class="line">    { 0x08, <span class="charliteral">&#39;e&#39;</span>},</div>
<div class="line">    { 0x09, <span class="charliteral">&#39;f&#39;</span>},</div>
<div class="line">    { 0x0A, <span class="charliteral">&#39;g&#39;</span>},</div>
<div class="line">    { 0x0B, <span class="charliteral">&#39;h&#39;</span>},</div>
<div class="line">    { 0x0C, <span class="charliteral">&#39;i&#39;</span>},</div>
<div class="line">    { 0x0D, <span class="charliteral">&#39;j&#39;</span>},</div>
<div class="line">    { 0x0E, <span class="charliteral">&#39;k&#39;</span>},</div>
<div class="line">    { 0x0F, <span class="charliteral">&#39;l&#39;</span>},</div>
<div class="line">    { 0x10, <span class="charliteral">&#39;m&#39;</span>},</div>
<div class="line">    { 0x11, <span class="charliteral">&#39;n&#39;</span>},</div>
<div class="line">    { 0x12, <span class="charliteral">&#39;o&#39;</span>},</div>
<div class="line">    { 0x13, <span class="charliteral">&#39;p&#39;</span>},</div>
<div class="line">    { 0x14, <span class="charliteral">&#39;q&#39;</span>},</div>
<div class="line">    { 0x15, <span class="charliteral">&#39;r&#39;</span>},</div>
<div class="line">    { 0x16, <span class="charliteral">&#39;s&#39;</span>},</div>
<div class="line">    { 0x17, <span class="charliteral">&#39;t&#39;</span>},</div>
<div class="line">    { 0x18, <span class="charliteral">&#39;u&#39;</span>},</div>
<div class="line">    { 0x19, <span class="charliteral">&#39;v&#39;</span>},</div>
<div class="line">    { 0x1A, <span class="charliteral">&#39;w&#39;</span>},</div>
<div class="line">    { 0x1B, <span class="charliteral">&#39;x&#39;</span>},</div>
<div class="line">    { 0x1C, <span class="charliteral">&#39;y&#39;</span>},</div>
<div class="line">    { 0x1D, <span class="charliteral">&#39;z&#39;</span>},</div>
<div class="line">    { 0x1E, <span class="charliteral">&#39;1&#39;</span>},</div>
<div class="line">    { 0x1F, <span class="charliteral">&#39;2&#39;</span>},</div>
<div class="line">    { 0x20, <span class="charliteral">&#39;3&#39;</span>},</div>
<div class="line">    { 0x21, <span class="charliteral">&#39;4&#39;</span>},</div>
<div class="line">    { 0x22, <span class="charliteral">&#39;5&#39;</span>},</div>
<div class="line">    { 0x23, <span class="charliteral">&#39;6&#39;</span>},</div>
<div class="line">    { 0x24, <span class="charliteral">&#39;7&#39;</span>},</div>
<div class="line">    { 0x25, <span class="charliteral">&#39;8&#39;</span>},</div>
<div class="line">    { 0x26, <span class="charliteral">&#39;9&#39;</span>},</div>
<div class="line">    { 0x27, <span class="charliteral">&#39;0&#39;</span>},</div>
<div class="line">    { 0x2C, <span class="charliteral">&#39; &#39;</span>},</div>
<div class="line">    { 0x37, <span class="charliteral">&#39;.&#39;</span>}</div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li>Add the keyboard and mouse HID reports. These reports are generated according to HID spec and HID Usage Tables specification. <div class="fragment"><div class="line"><span class="keyword">const</span> uint8_t hid_report_keyboard[] =</div>
<div class="line">{</div>
<div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div>
<div class="line">    USB_HID_USAGE_PAGE_GENERIC_DESKTOP,</div>
<div class="line">    USB_HID_LOCAL_USAGE + 1,</div>
<div class="line">    USB_HID_USAGE_KEYBOARD,</div>
<div class="line">    USB_HID_MAIN_COLLECTION + 1,</div>
<div class="line">    USB_HID_COLLECTION_APPLICATION,</div>
<div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div>
<div class="line">    7,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MINIMUM + 1,</div>
<div class="line">    224,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MAXIMUM + 1,</div>
<div class="line">    231,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div>
<div class="line">    0,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div>
<div class="line">    8,</div>
<div class="line">    USB_HID_MAIN_INPUT + 1,</div>
<div class="line">    USB_HID_VARIABLE,</div>
<div class="line">    USB_HID_MAIN_INPUT + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MINIMUM + 1,</div>
<div class="line">    0,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MAXIMUM + 1,</div>
<div class="line">    101,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div>
<div class="line">    0,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div>
<div class="line">    101,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div>
<div class="line">    8,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div>
<div class="line">    6,</div>
<div class="line">    USB_HID_MAIN_INPUT + 1,</div>
<div class="line">    0,</div>
<div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div>
<div class="line">    USB_HID_USAGE_PAGE_LEDS,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MINIMUM + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MAXIMUM + 1,</div>
<div class="line">    5,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div>
<div class="line">    0,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div>
<div class="line">    5,</div>
<div class="line">    USB_HID_MAIN_OUTPUT + 1,</div>
<div class="line">    2,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div>
<div class="line">    3,</div>
<div class="line">    USB_HID_MAIN_OUTPUT + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_MAIN_ENDCOLLECTION</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">const</span> uint8_t hid_report_mouse[] =</div>
<div class="line">{</div>
<div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div>
<div class="line">    USB_HID_USAGE_PAGE_GENERIC_DESKTOP,</div>
<div class="line">    USB_HID_LOCAL_USAGE + 1,</div>
<div class="line">    USB_HID_USAGE_MOUSE,</div>
<div class="line">    USB_HID_MAIN_COLLECTION + 1,</div>
<div class="line">    USB_HID_COLLECTION_APPLICATION,</div>
<div class="line">    USB_HID_LOCAL_USAGE + 1,</div>
<div class="line">    USB_HID_USAGE_POINTER,</div>
<div class="line">    USB_HID_MAIN_COLLECTION + 1,</div>
<div class="line">    USB_HID_COLLECTION_PHYSICAL,</div>
<div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div>
<div class="line">    USB_HID_USAGE_PAGE_BUTTON,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MINIMUM + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_LOCAL_USAGE_MAXIMUM + 1,</div>
<div class="line">    3,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div>
<div class="line">    0,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div>
<div class="line">    3,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_MAIN_INPUT + 1,</div>
<div class="line">    USB_HID_VARIABLE, <span class="comment">/* 3 button bits */</span></div>
<div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div>
<div class="line">    1,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div>
<div class="line">    5,</div>
<div class="line">    USB_HID_MAIN_INPUT + 1,</div>
<div class="line">    USB_HID_CONSTANT, <span class="comment">/* 5 bit padding */</span></div>
<div class="line">    USB_HID_GLOBAL_USAGE_PAGE + 1,</div>
<div class="line">    USB_HID_USAGE_PAGE_GENERIC_DESKTOP,</div>
<div class="line">    USB_HID_LOCAL_USAGE + 1,</div>
<div class="line">    USB_HID_USAGE_X,</div>
<div class="line">    USB_HID_LOCAL_USAGE + 1,</div>
<div class="line">    USB_HID_USAGE_Y,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MINIMUM + 1,</div>
<div class="line">    (<span class="keywordtype">unsigned</span> char)-127,</div>
<div class="line">    USB_HID_GLOBAL_LOGICAL_MAXIMUM + 1,</div>
<div class="line">    127,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_SIZE + 1,</div>
<div class="line">    8,</div>
<div class="line">    USB_HID_GLOBAL_REPORT_COUNT + 1,</div>
<div class="line">    2,</div>
<div class="line">    USB_HID_MAIN_INPUT + 1,</div>
<div class="line">    USB_HID_VARIABLE | USB_HID_RELATIVE,</div>
<div class="line">    USB_HID_MAIN_ENDCOLLECTION,</div>
<div class="line">    USB_HID_MAIN_ENDCOLLECTION</div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li>Add the functions for adding the keyboard and the mouse to the USB stack. <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div>
<div class="line"><span class="comment">* Function Name: add_keyboard</span></div>
<div class="line"><span class="comment">********************************************************************************</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* Adds the HID keyboard device to the USB stack.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* \return Keyboard handler</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">*******************************************************************************/</span></div>
<div class="line"><span class="keyword">static</span> USB_HID_HANDLE add_keyboard(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    USB_HID_INIT_DATA init_data;</div>
<div class="line">    USB_ADD_EP_INFO   ep_int_in;</div>
<div class="line">    USB_HID_HANDLE    keyboard_handler;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets the init_data elements with 0 */</span></div>
<div class="line">    memset(&amp;init_data, 0, <span class="keyword">sizeof</span>(init_data));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets the flags of the not-used state */</span></div>
<div class="line">    ep_int_in.Flags = 0;</div>
<div class="line">    <span class="comment">/* Sets the IN-direction (Device to Host) */</span></div>
<div class="line">    ep_int_in.InDir = USB_DIR_IN;</div>
<div class="line">    <span class="comment">/* Sets the interval of 8 ms (125 us * 64) */</span></div>
<div class="line">    ep_int_in.Interval = 64;</div>
<div class="line">    <span class="comment">/* Sets the maximum packet size (64 for Interrupt) */</span></div>
<div class="line">    ep_int_in.MaxPacketSize = USB_HS_INT_MAX_PACKET_SIZE;</div>
<div class="line">    <span class="comment">/* Sets the endpoint type as Interrupt */</span></div>
<div class="line">    ep_int_in.TransferType = USB_TRANSFER_TYPE_INT;</div>
<div class="line">    <span class="comment">/* Initializes the endpoint handle data */</span></div>
<div class="line">    init_data.EPIn = USBD_AddEPEx(&amp;ep_int_in, NULL, 0);</div>
<div class="line">    <span class="comment">/* Gets the pointer to a report mouse descriptor */</span></div>
<div class="line">    init_data.pReport = hid_report_keyboard;</div>
<div class="line">    <span class="comment">/* Initializes the size of the HID report descriptor */</span></div>
<div class="line">    init_data.NumBytesReport = <span class="keyword">sizeof</span>(hid_report_keyboard);</div>
<div class="line">    <span class="comment">/* Adds an HID keyboard device to the USB interface */</span></div>
<div class="line">    keyboard_handler = USBD_HID_Add(&amp;init_data);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> keyboard_handler;</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div>
<div class="line"><span class="comment">* Function Name: add_mouse</span></div>
<div class="line"><span class="comment">********************************************************************************</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* Adds the HID mouse device to the USB stack.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* \return Mouse handler</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">*******************************************************************************/</span></div>
<div class="line"><span class="keyword">static</span> USB_HID_HANDLE add_mouse(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    USB_HID_INIT_DATA init_data;</div>
<div class="line">    USB_ADD_EP_INFO   ep_int_in;</div>
<div class="line">    USB_HID_HANDLE    mouse_handler;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets the init_data elements to 0 value */</span></div>
<div class="line">    memset(&amp;init_data, 0, <span class="keyword">sizeof</span>(init_data));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets the flags of the not-used state */</span></div>
<div class="line">    ep_int_in.Flags = 0;</div>
<div class="line">    <span class="comment">/* Sets the IN-direction (Device to Host) */</span></div>
<div class="line">    ep_int_in.InDir = USB_DIR_IN;</div>
<div class="line">    <span class="comment">/* Sets the interval of 8 ms (125 us * 64) */</span></div>
<div class="line">    ep_int_in.Interval = 64;</div>
<div class="line">    <span class="comment">/* Sets the maximum packet size (64 for Interrupt) */</span></div>
<div class="line">    ep_int_in.MaxPacketSize = USB_HS_INT_MAX_PACKET_SIZE;</div>
<div class="line">    <span class="comment">/* Sets the endpoint type as Interrupt */</span></div>
<div class="line">    ep_int_in.TransferType = USB_TRANSFER_TYPE_INT;</div>
<div class="line">    <span class="comment">/* Initializes the endpoint handle data */</span></div>
<div class="line">    init_data.EPIn = USBD_AddEPEx(&amp;ep_int_in, NULL, 0);</div>
<div class="line">    <span class="comment">/* Gets the pointer to a report mouse descriptor */</span></div>
<div class="line">    init_data.pReport = hid_report_mouse;</div>
<div class="line">    <span class="comment">/* Initializes the size of the HID report descriptor */</span></div>
<div class="line">    init_data.NumBytesReport = <span class="keyword">sizeof</span>(hid_report_mouse);</div>
<div class="line">    <span class="comment">/* Adds an HID mouse device to the USB interface */</span></div>
<div class="line">    mouse_handler = USBD_HID_Add(&amp;init_data);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> mouse_handler;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Add the function for writing the keyboard data to the host. <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div>
<div class="line"><span class="comment">* Function Name: keyboard_send_text</span></div>
<div class="line"><span class="comment">********************************************************************************</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* Writes the keyboard data to the host.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* \param keyboard_handler  The HID keyboard device handler.</span></div>
<div class="line"><span class="comment">* \param keyboard_text  The text data to send to the host.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">*******************************************************************************/</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> keyboard_send_text(USB_HID_HANDLE keyboard_handler, <span class="keyword">const</span> <span class="keywordtype">char</span>* keyboard_text)</div>
<div class="line">{</div>
<div class="line">    uint8_t  char_arr[8];</div>
<div class="line">    <span class="keywordtype">char</span>     char_temp;</div>
<div class="line">    uint32_t i;</div>
<div class="line">    uint32_t j;</div>
<div class="line">    uint32_t key_code_to_string_table_size;</div>
<div class="line"> </div>
<div class="line">    key_code_to_string_table_size = ((<span class="keyword">sizeof</span>(key_code_to_string_table)) / (<span class="keyword">sizeof</span>(key_code_to_string_table[0])));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets all char_arr elements with 0 */</span></div>
<div class="line">    memset(char_arr, 0, <span class="keyword">sizeof</span>(char_arr));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; keyboard_text[i] != 0; i++)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* A character is uppercase if its hex value is less than 0x61 (&#39;a&#39;)</span></div>
<div class="line"><span class="comment">         * and greater or equal to 0x41 (&#39;A&#39;), therefore we set the LeftShiftUp</span></div>
<div class="line"><span class="comment">         * bit for those characters</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        <span class="keywordflow">if</span> (keyboard_text[i] &lt; 0x61 &amp;&amp; keyboard_text[i] &gt;= 0x41)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* Disables LeftShiftUp */</span></div>
<div class="line">            char_arr[0] = (1 &lt;&lt; 1);</div>
<div class="line">            <span class="comment">/* Converts the character to lowercase */</span></div>
<div class="line">            char_temp = tolower((<span class="keywordtype">int</span>)keyboard_text[i]);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            char_temp = keyboard_text[i];</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (j = 0; j &lt; key_code_to_string_table_size; j++)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (key_code_to_string_table[j].key_char == char_temp)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">/* Gets the character code */</span></div>
<div class="line">                char_arr[2] = key_code_to_string_table[j].key_code;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Writes data to the host */</span></div>
<div class="line">        USBD_HID_Write(keyboard_handler, <span class="comment">/* The HID instance */</span></div>
<div class="line">            &amp;char_arr[0],                <span class="comment">/* The pointer to the data array to send */</span></div>
<div class="line">            8u,                          <span class="comment">/* The number of bytes to send */</span></div>
<div class="line">            0);                          <span class="comment">/* The Timeout in milliseconds */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Sets all char_arr elements with 0 */</span></div>
<div class="line">        memset(char_arr, 0, <span class="keyword">sizeof</span>(char_arr));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Send a 0 field packet to tell the host that the key has been released */</span></div>
<div class="line">        USBD_HID_Write(keyboard_handler, <span class="comment">/* The HID instance */</span></div>
<div class="line">            &amp;char_arr[0],                <span class="comment">/* The pointer to the data array to send */</span></div>
<div class="line">            8u,                          <span class="comment">/* The number of bytes to send */</span></div>
<div class="line">            0);                          <span class="comment">/* The Timeout in milliseconds */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* The delay is 50 milliseconds */</span></div>
<div class="line">        USB_OS_Delay(50);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Add the function for writing the mouse movements data to the host. <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div>
<div class="line"><span class="comment">* Function Name: mouse_moves</span></div>
<div class="line"><span class="comment">********************************************************************************</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* Writes the mouse movements data to the host.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* \param mouse_handler  The HID mouse device handler.</span></div>
<div class="line"><span class="comment">* \param mouse_move gets data about the mouse movement.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">*******************************************************************************/</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> mouse_moves(USB_HID_HANDLE mouse_handler, int8_t mouse_move)</div>
<div class="line">{</div>
<div class="line">    uint8_t move_arr[3];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets all move_arr elements with 0 */</span></div>
<div class="line">    memset(move_arr, 0, <span class="keyword">sizeof</span>(move_arr));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Gets the mouse movement value */</span></div>
<div class="line">    move_arr[1] = (uint8_t)mouse_move;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Writes data to the host */</span></div>
<div class="line">    USBD_HID_Write(mouse_handler, <span class="comment">/* The HID instance */</span></div>
<div class="line">        &amp;move_arr[0],             <span class="comment">/* The pointer to the data array to send */</span></div>
<div class="line">        3u,                       <span class="comment">/* The number of bytes to send */</span></div>
<div class="line">        0);                       <span class="comment">/* The Timeout in milliseconds */</span></div>
<div class="line"> </div>
<div class="line">    USB_OS_Delay(1000);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli">Initialize retarget-io to use the debug UART port:</p>
<p class="startli"><b> For CAT1A devices:</b></p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> retarget_io_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Configures the retarget_io pins */</span></div>
<div class="line">    cy_rslt_t result;</div>
<div class="line">    result = cy_retarget_io_init(CYBSP_DEBUG_UART_TX, CYBSP_DEBUG_UART_RX, CY_RETARGET_IO_BAUDRATE);</div>
<div class="line">    <span class="keywordflow">if</span> (CY_RSLT_SUCCESS != result)</div>
<div class="line">    {</div>
<div class="line">        CY_ASSERT(0);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p class="startli"><b> For CAT3 devices:</b></p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> retarget_io_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Configures the retarget_io pins */</span></div>
<div class="line">    cy_rslt_t result;</div>
<div class="line">    result = cy_retarget_io_init(CYBSP_DEBUG_UART_HW);</div>
<div class="line">    <span class="keywordflow">if</span> (CY_RSLT_SUCCESS != result)</div>
<div class="line">    {</div>
<div class="line">        XMC_ASSERT(0, <span class="stringliteral">&quot;cy_retarget_io_init returns error status&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Create the main_task() function <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div>
<div class="line"><span class="comment">* Function Name: main_task</span></div>
<div class="line"><span class="comment">********************************************************************************</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* Initializes the emUSB-Device stack.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">* \param arg  is not used in this function but required for using FreeRTOS.</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">*******************************************************************************/</span></div>
<div class="line"><span class="keywordtype">void</span> main_task(<span class="keywordtype">void</span>* arg)</div>
<div class="line">{</div>
<div class="line">    (void)arg;</div>
<div class="line"> </div>
<div class="line">    retarget_io_init();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Mouse movement values */</span></div>
<div class="line">    int8_t mouse_move_left = -75;</div>
<div class="line">    int8_t mouse_move_right = 75;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* The output text from the keyboard */</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* keyboard_text = <span class="stringliteral">&quot;Hello world! &quot;</span>;</div>
<div class="line"> </div>
<div class="line">    USB_HID_HANDLE mouse_handler;</div>
<div class="line">    USB_HID_HANDLE keyboard_handler;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Initialization of emUSB-Device */</span></div>
<div class="line">    USBD_Init();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Adds the HID keyboard device to the USB stack */</span></div>
<div class="line">    keyboard_handler = add_keyboard();</div>
<div class="line">    <span class="comment">/* Adds the HID mouse device to the USB stack */</span></div>
<div class="line">    mouse_handler = add_mouse();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets information used during the device enumeration */</span></div>
<div class="line">    USBD_SetDeviceInfo(&amp;device_info);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Starts emUSB-Device */</span></div>
<div class="line">    USBD_Start();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (1)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Waits for configuration */</span></div>
<div class="line">        <span class="keywordflow">while</span> ((USBD_GetState() &amp; (USB_STAT_CONFIGURED | USB_STAT_SUSPENDED)) != USB_STAT_CONFIGURED)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* Do something to indicate waiting for configuration */</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Moves the mouse cursor left and right */</span></div>
<div class="line">        mouse_moves(mouse_handler, mouse_move_left);</div>
<div class="line">        mouse_moves(mouse_handler, mouse_move_right);</div>
<div class="line">        <span class="comment">/* Prints the text */</span></div>
<div class="line">        keyboard_send_text(keyboard_handler, keyboard_text);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli">Call main_task():</p>
<p class="startli"><b> For non-RTOS environments:</b></p>
<p class="startli">Call the main_task() into the main() function. </p><div class="fragment"><div class="line">    main_task(NULL);</div>
</div><!-- fragment --><p class="startli"><b> For RTOS environments:</b></p>
<p class="startli">Create a FreeRTOS task with main_task() using xTaskCreate and start the task scheduler instead of calling main_task(): </p><div class="fragment"><div class="line">    <span class="comment">/* Creates a FreeRTOS task of the main_task() function */</span></div>
<div class="line">    xTaskCreate(main_task, <span class="stringliteral">&quot;main_task&quot;</span>, 500U, NULL, configMAX_PRIORITIES - 6, NULL);</div>
<div class="line">    vTaskStartScheduler();</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Typically, the default interrupt priority-configuration from the usbd_config.c file will work with the default FreeRTOS config file. For a malfunction USB project, ensure that the USB interrupt priority is aligned with MAX_API_CALL_INTERRUPT_PRIORITY. See <a class="el" href="index.html#section_emusb_device_use_in_rtos">Using emUSB-Device in an RTOS Environment</a>.</dd></dl>
</li>
</ol>
<h2><a class="anchor" id="subsection_qsg_step5"></a>
STEP 4: Check the emUSB-Device workability.</h2>
<ol type="1">
<li>Build and program your project.</li>
<li>Connect the USB-Device connector to the PC host.</li>
<li>Observe the mouse cursor move and print the "Hello world" message into the text editor.</li>
</ol>
<h1><a class="anchor" id="section_emusb_device_config_cons"></a>
Configuration Considerations</h1>
<p >This section explains the details of the emUSB-Device configuration.</p>
<h2><a class="anchor" id="section_emusb_device_hw_dep_conf"></a>
Hardware-dependent Configuration</h2>
<p >The hardware resources (Pins, clocks, interrupts) required for USB must be configured before the start of USB operation before calling USBD_Init() or in USBD_X_Config(). Interrupts must be configured in the USBD_X_Config() function. Also, USBD_X_EnableInterrupt() and USBD_X_DisableInterrupt() must be implemented when the USBD_OS_USE_USBD_X_INTERRUPT compile time option is enabled.</p>
<p >The implementation template of USBD_X_Config(), USBD_X_EnableInterrupt() and USBD_X_DisableInterrupt() is provided for each device category in the Config directory under COMPONENT_CATx. This template is automatically copied into your project when middleware is added to project. This template does not include the configuration of clock and pins required for USB operation.</p>
<p >For details on Hardware Dependent Configuration, refer to the - <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a>.</p>
<h3><a class="anchor" id="section_emusb_device_hw_dep_conf_pins"></a>
USB Pins Configuration</h3>
<p ><b> CAT1A Devices Family </b></p>
<p >The D+ and D- pins must be configured for USB operation. The emUSB-Host/Device personality in the Device Configurator allows for easy configuration of configuration of the pins. Otherwise, the pins can be configured manually by PDL APIs.</p>
<p >The following snippet initializes GPIO pins for USB operation by <a href="https://github.com/Infineon/mtb-pdl-cat1"><b>mtb-pdl-cat1 APIs</b></a>.</p>
<div class="fragment"><div class="line">    Cy_GPIO_Pin_FastInit(USBDP_PORT, USBDP_PIN, CY_GPIO_DM_ANALOG, 0U, USBDP_GPIO);</div>
<div class="line">    Cy_GPIO_Pin_FastInit(USBDM_PORT, USBDM_PIN, CY_GPIO_DM_ANALOG, 0U, USBDM_GPIO);</div>
</div><!-- fragment --><p ><b> CAT3 Devices Family </b></p>
<p >The D+/D- pins are dedicated and do not require configuration.</p>
<h3><a class="anchor" id="section_emusb_device_hw_dep_conf_clock"></a>
USB Clock Configuration</h3>
<p >The USB 2.0 specification defines the required bit rate accuracy for the device in section 7.1.11. Ensure that the clock sources for USB meet the requirements.</p>
<p >The emUSB-Host/Device personality in the Device Configurator allows for easy configuration of the clocks for USB operation and also check if the clocks meet the requirements. Otherwise, the clocks can be configured manually by PDL/HAL APIs for CAT1A and by XMCLIB for CAT3.</p>
<p ><b> CAT1A Devices Family </b></p>
<p >The USB device requires two clocks for operation:</p><ul>
<li>Clock the main clock at 48 MHz. Typically, the main clock is CLK_HF3 output signal, but refer to the device datasheet to identify the clock source for USB for a specific device.</li>
<li>Clock the Clock (Bus Reset) at 100 kHz. Typically, Clock (Bus Reset) is connected to CLK_PERI through peripheral clock dividers but refer to the device datasheet to identify the Clock (Bus Reset) source for USB for a specific device.</li>
</ul>
<p >Both these clocks must be configured with the defined bit rate accuracy per USB 2.0 specification.</p>
<dl class="section note"><dt>Note</dt><dd>Ensure that the clock sources for USB meet the requirements.</dd></dl>
<p><b> CAT3 Devices Family </b></p>
<p >The USB Device requires two clocks for operation:</p><ul>
<li>The USB Phy Clock output must be configured at 48 MHz frequency with required bit rate accuracy according to the USB 2.0 specification.</li>
<li>The second USB clock is connected to CPU clock. The CPU clock should be set to highest frequency as possible according to application design. If the CPU clock will have too low frequency the some of USB functionality won't work properly. For more details, refer to the Reference Manual of your CAT3 device.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If the USB must operate during Deep Sleep, keep both clocks enabled.</dd></dl>
<h3><a class="anchor" id="section_emusb_device_hw_dep_conf_int"></a>
USB Interrupt Configuration</h3>
<p >The interrupt is mandatory for the emUSB-Device Middleware operation. The interrupt priority selection is a part of Application level - the interrupt priority selected in the template files is not suitable for real project. For USB recommended setting the interrupt priority as high as possible.</p>
<p ><b> CAT1A Devices Family </b></p>
<p >emUSB-Device uses only one interrupt source from the three available in the IP USB block - usb_interrupt_med_IRQn. The emUSB-Device code can be executed on CM4 and CM0+ cores. For CM0+, the interrupt source of the USB IP block can be connected to one of CM0+ IRQs. Refer to the device datasheet and <a href="https://infineon.github.io/mtb-pdl-cat1/pdl_api_reference_manual/html/group__group__sysint.html"><b>SysInt (System Interrupt) Driver documentation</b></a> to find the available IRQs for CM0+.</p>
<ul>
<li>The following code snippet shows the interrupt configuration for both CM4 and CM0+ cores. <div class="fragment"><div class="line"><span class="comment">/* Define the interrupt source */</span></div>
<div class="line"><span class="preprocessor">#if (COMPONENT_CM0P)</span></div>
<div class="line"><span class="comment">/* The number of CM0+ interrupt vectors is different for different devices,</span></div>
<div class="line"><span class="comment"> * so, change the following macro for your selected device.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define USBD_INTERRUPT_NUM                      (NvicMux7_IRQn)</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#define USBD_INTERRUPT_NUM                      (usb_interrupt_med_IRQn)</span></div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* #if (COMPONENT_CM0P) */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Define the interrupt priority */</span></div>
<div class="line"><span class="preprocessor">#define USBD_ISR_PRIO                           (3U)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Register this function as a callback in USBD_SetISREnableFunc(). */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> enable_isr(USB_ISR_HANDLER * pfISRHandler)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Install interrupt service routine */</span></div>
<div class="line">    cy_rslt_t result;</div>
<div class="line">    result = cyhal_system_set_isr(USBD_INTERRUPT_NUM, usb_interrupt_med_IRQn, USBD_ISR_PRIO, pfISRHandler);</div>
<div class="line">    CY_ASSERT(CY_RSLT_SUCCESS == result);</div>
<div class="line">    (void) result; <span class="comment">/* To avoid the compiler warning in Release mode */</span></div>
<div class="line"> </div>
<div class="line">    NVIC_EnableIRQ(USBD_INTERRUPT_NUM);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The number of CM0+ interrupt vectors is different for different devices, so, this code snippet may not be suitable for all devices.</dd></dl>
<p><b> CAT3 Devices Family </b></p>
<p >CAT3 devices have only one interrupt source in the IP USB block - USB0_0_IRQn.</p>
<ul>
<li>The following code snippet shows the interrupt configuration for CAT3 devices: <div class="fragment"><div class="line"><span class="comment">/* Define interrupt priority. In case of FreeRTOS ensure that</span></div>
<div class="line"><span class="comment"> * configMAX_SYSCALL_INTERRUPT_PRIORITY in FreeRTOSConfig.h is</span></div>
<div class="line"><span class="comment"> * configured in accordance to XMC4xxx interrupts configuration</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define USBD_ISR_PRIO                           (63U)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> USB_ISR_HANDLER * p_usb_isr_handler;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*********************************************************************</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">*       USB0_0_IRQHandler</span></div>
<div class="line"><span class="comment">*  Function description</span></div>
<div class="line"><span class="comment">*    USB IRQ Handler</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> USB0_0_IRQHandler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    (p_usb_isr_handler)();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Register this function as a callback in USBD_SetISREnableFunc(). */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> enable_isr(USB_ISR_HANDLER * pfISRHandler)</div>
<div class="line">{</div>
<div class="line">    p_usb_isr_handler = pfISRHandler;</div>
<div class="line">    NVIC_SetPriority(USB0_0_IRQn, USBD_ISR_PRIO);</div>
<div class="line">    NVIC_EnableIRQ(USB0_0_IRQn);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="section_emusb_device_hw_dep_add_conf_cat3_stack"></a>
CAT3 Specific Configuration</h3>
<p >Some of CAT3 devices features, which affect the USB functionality are implemented outside of USB IP block and can not be configured inside emUSB-Device middleware. These features include: enable/disable power to the USB IP block, enable/disable reset state for the USB IP block and enable/disable the pull-up resistor. All mentioned features can be configured by SCU driver from mtb-xmclib-cat3.</p>
<p >Additional USB configuration steps for CAT3 devices:</p><ol type="1">
<li>Enable the power for USB by using <em>XMC_SCU_POWER_EnableUsb()</em>.</li>
<li>De-assert Reset from USB controller by calling <em>XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USB0)</em> for executing the USB functionality.</li>
<li>Create the callback function which enable USB weak pull-up resistor by <em>XMC_SCU_PCU_EnableUsbPullUp()</em> as it shown in the following code snippet. <div class="fragment"><div class="line"><span class="comment">/*********************************************************************</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">*       hw_attach</span></div>
<div class="line"><span class="comment">*  Function description</span></div>
<div class="line"><span class="comment">*    Enable USB weak pull-up at PADN state</span></div>
<div class="line"><span class="comment">*</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> hw_attach(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    XMC_SCU_PCU_EnableUsbPullUp();</div>
<div class="line">}</div>
</div><!-- fragment --> The described callback is registers into <em>USBD_SetAttachFunc()</em>. <dl class="section note"><dt>Note</dt><dd>It is recommended to enable pull-up only inside a callback registered by USBD_SetAttachFunc().</dd></dl>
Those steps are already implemented in usbd_config.c for CAT3 devices. You can use this file as reference.</li>
</ol>
<h3><a class="anchor" id="section_emusb_device_dma_cat1a"></a>
DMA driver for CAT1A device</h3>
<p >To use the driver with DMA support:</p><ol type="1">
<li>Add USBD_ENABLE_DMA to the DEFINE variable in Makefile</li>
<li>Connect the USB endpoints to a DMA channel in the USB personality or do it manually using APIs for the TrigMux driver. All used data endpoints must be connected to corresponding DMA channels.</li>
<li>Enable the DMA block before starting emUSB-Device by Cy_DMA_Enable()</li>
<li>Add DMA USB_Driver_Cypress_PSoC6_DMA driver by USBD_AddDriver().</li>
<li>Allocate memory for the endpoints transfer-buffer by USBD_AssignMemory().</li>
<li>Configure DMA parameters and DMA routines by USB_DRIVER_Cypress_PSoC6_ConfigDMA()</li>
</ol>
<p >Steps 3-6 are implemented in the usbd_config.c file.</p>
<p >The emUSB-Device configures a DMA channel inside the USB driver, so, no need to configure a DMA channel in the application code or in the DMA personality. Configuration of a DMA channel in the DMA personality is ignored, the enable the resource for reservation and connecting the USB endpoints to available DMA channels.</p>
<dl class="section note"><dt>Note</dt><dd>When DMA mode is enabled in the USB personality, the USB personality generates several macros used in the usbd_config.c file.</dd></dl>
<h2><a class="anchor" id="section_emusb_device_debug_mes_out"></a>
Debug Message Output</h2>
<p >The debug builds of emUSB-Device allow using the debug message outputs. The template implementation of the message output functions is in export/Config/usbd_config_io.c file. This file is automatically copied into the ModusToolbox project when emUSB-Device middleware is added for the first time by the Library manager. Otherwise, copy this file manually. By default, <a href="https://github.com/Infineon/retarget-io"><b>retarget-io</b></a> is used for the message output, but message outputs can be redefined to any suitable output way. To disable the default message outputs, set USBD_DISABLE_STANDARD_OUTPUT=1 in the DEFINES variable in the application project Makefile. To provide a custom output method in addition to setting a variable add corresponding API under the #if (USBD_DISABLE_STANDARD_OUTPUT == 1U) condition inside the _puts() function.</p>
<p >For details on Hardware Debug Message Output, refer to the - <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> Debugging chapter.</p>
<dl class="section note"><dt>Note</dt><dd>The retarget-io middleware must be configured outside of the emUSB-Device middleware for the message output. Refer to the <a href="https://github.com/Infineon/retarget-io#quick-start"><b>retarget-io Quick Start</b></a>.</dd>
<dd>
The retarget-io does not send the debug message from the interrupt in RTOS aware environments. These messages are ignored. But some of them can be critical for debugging. For this case recommended to use other message output method to print all messages.</dd></dl>
<h2><a class="anchor" id="section_emusb_device_low_power"></a>
Low Power Support</h2>
<p >The USB Host can initiate Suspend condition on the USB bus to reduce power consumption of the connected device. emUSB-Device can identify Suspend condition in a few ways. For example: calling USBD_GetState() through a specific time interval (typically 1 ms), by the callback function registered in USBD_RegisterSCHook() or by the other ways supported in the emUSB-Device stack. When Suspend condition is identified, the suspended device must limits the current consumption from VBUS to 0.5 mA. Therefore, put the device into Low-power mode to consume less current. emUSB-Device does not change the microcontroller Power mode by itself. It is the application responsibility to reduce power consumption to meet the requirements. Also, it is the application responsibility to prepare emUSB-Device for low-power mode and detect Resume condition. The preparation of the emUSB-Device middleware for low-power mode and detection of Resume condition differ among devices. Pay attention for the following explanation for the required devices.</p>
<p >Refer to the - <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> Low power mode chapter for additional information about the behavior of emUSB-Device in low-power mode.</p>
<p >Typically, the microcontroller enters Deep Sleep or similar mode to achieve the required current consumption, but other approaches are also possible if they exist. The next table shows the recommended low-power modes for Suspend state for each supported device:</p>
<table class="doxtable">
<tr>
<th>Device family</th><th>Recommended low-power mode </th></tr>
<tr>
<td>CAT1A </td><td>Deep Sleep  </td></tr>
<tr>
<td>CAT3 </td><td>Deep Sleep  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>After a wake-up from low-power modes in which USB IP block cannot operate, the emUSB-Device must be re-initialized (Except Deep Sleep mode for CAT1A device).</dd></dl>
<p><b> CAT1A Devices Family </b></p>
<p >The USB IP block operates in Active and Sleep mode without any limitations, but in Deep Sleep, the USB IP block is disabled.</p>
<dl class="section note"><dt>Note</dt><dd>No need to call USBD_DeInit() or USBD_Stop() before entering low-power mode and USBD_Init() or USBD_Start() after wake up contrary to described in <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> Low power mode chapter. If they are called, emUSB-Device does not return from Deep Sleep to the previous state after a wake up. The USB Host will probably identify some sets of events like disconnecting the old device and connecting a new device.</dd></dl>
<p>emUSB-Device has two additional functions only for CAT1A devices, which take part in detecting Suspend condition and restoring emUSB-Device after Deep Sleep - USB_DRIVER_Cypress_PSoC6_SysTick() and USB_DRIVER_Cypress_PSoC6_Resume(). The application must call USB_DRIVER_Cypress_PSoC6_SysTick() every millisecond in order to get suspend events handled. The USB_DRIVER_Cypress_PSoC6_Resume() function must be called after waking up from Deep Sleep low-power mode. For details, about these functions refer to the <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> PSoC6 driver chapter.</p>
<dl class="section note"><dt>Note</dt><dd>After waking up from Deep Sleep, USBD_GetState() can returns the Suspend status for some time. Wait up to 10 milliseconds and then check the USB status with USBD_GetState() because USB_DRIVER_Cypress_PSoC6_SysTick() requires some time for identifying the Resume condition.</dd></dl>
<p>The USB IP block is disabled during Deep Sleep mode, so, additional configuration of the D+ pins is required. Configure the falling edge interrupt on the D+ pin (before entering Deep Sleep) to exit low-power mode when the Host drivers resume. The interrupt on the D+ pin wakes up the device from low-power mode when the Host drivers resume. The interrupt is allowed only when emUSB-Device is in Suspended state and the microcontroller in Deep Sleep mode to prevent frequent triggering of GPIO interrupt and loading CPU.</p>
<div class="fragment"><div class="line"><span class="comment">/* Interrupt mask for D+ pin */</span></div>
<div class="line"><span class="preprocessor">#define GPIO_DP_INT_MASK                        (1U)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Configuration structure for D+ pin interrupt */</span></div>
<div class="line"><span class="keyword">static</span> cy_stc_sysint_t dp_pin_interrupt_cfg =</div>
<div class="line">{</div>
<div class="line">    .intrSrc = ioss_interrupts_gpio_14_IRQn,</div>
<div class="line">    .intrPriority = 0U,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Interrupt handler for D+ pin */</span></div>
<div class="line"><span class="keywordtype">void</span> dp_pin_isr(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Check if an interrupt on the D+ pin was generated */</span></div>
<div class="line">    <span class="keywordflow">if</span> (Cy_GPIO_GetInterruptStatusMasked(USBDP_PORT, USBDP_PIN))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Clear D+ interrupt flag */</span></div>
<div class="line">        Cy_GPIO_ClearInterrupt(USBDP_PORT, USBDP_PIN);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Initialize and configure an interrupt for the D+ pin to detect Resume condition */</span></div>
<div class="line"><span class="keywordtype">void</span> init_dp_interrupt(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Initialize an interrupt on the D+ pin to detect Resume condition */</span></div>
<div class="line">    <span class="keywordflow">if</span> (CY_RSLT_SUCCESS != Cy_SysInt_Init(&amp;dp_pin_interrupt_cfg, &amp;dp_pin_isr))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Insert error handler */</span></div>
<div class="line">        CY_ASSERT(0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Set up generation of an interrupt on the falling edge */</span></div>
<div class="line">    Cy_GPIO_SetInterruptEdge(USBDP_PORT, USBDP_PIN, CY_GPIO_INTR_FALLING);</div>
<div class="line">    Cy_GPIO_SetInterruptMask(USBDP_PORT, USBDP_PIN, GPIO_DP_INT_MASK);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>For a non-RTOS environment, disable the default timer for measuring the tick count (set USBD_NORTOS_TICKCNT_ENABLE macro to 0 in Makefile) and provide a specific implementation. For details, see <a class="el" href="index.html#section_emusb_device_use_in_rtos">Using emUSB-Device in an RTOS Environment</a></dd></dl>
<p>The next code snippets show preparing/restoring emUSB-Device before/after Deep Sleep. </p><div class="fragment"><div class="line"><span class="comment">/* Enable interrupt for D+ pins before entering Deep Sleep</span></div>
<div class="line"><span class="comment"> * for detecting Resume condition on USB Bus</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> enable_dp_interrupt(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Clear D+ interrupt flag */</span></div>
<div class="line">    Cy_GPIO_ClearInterrupt(USBDP_PORT, USBDP_PIN);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Clear any pending interrupt */</span></div>
<div class="line">    NVIC_ClearPendingIRQ(dp_pin_interrupt_cfg.intrSrc);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Enable the D+ interrupt */</span></div>
<div class="line">    NVIC_EnableIRQ(dp_pin_interrupt_cfg.intrSrc);</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">/* Prepare emUSB-Device after wake-up from Deep Sleep</span></div>
<div class="line"><span class="comment"> * for further operation</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> prepare_emusb_after_lpm(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Disable the D+ interrupt */</span></div>
<div class="line">    NVIC_DisableIRQ(dp_pin_interrupt_cfg.intrSrc);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Resume emUSB-Device */</span></div>
<div class="line">    USB_DRIVER_Cypress_PSoC6_Resume();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Wait up to 10 milliseconds for updating emUSB-Device state */</span></div>
<div class="line">    USB_OS_Delay(10);</div>
<div class="line">}</div>
</div><!-- fragment --><p ><b> CAT3 Devices Family </b></p>
<p >The USB IP block can operate in Active, Sleep, and Deep Sleep mode. For Sleep and Deep Sleep modes, the USB IP block clocking must remain active. This means that USB Phy Clock and System Clock must be enabled during low-power modes. After detecting Resume condition, the CAT3 device exits Deep Sleep mode (The USB interrupt wake-up microcontroller) and enters Active power mode.</p>
<p >If Suspend condition is detected, the device goes to Deep Sleep mode but the USB remains enabled. Example of configuration CAT3 device with enabled USB during Deep Sleep mode: </p><div class="fragment"><div class="line">    XMC_SCU_CLOCK_SetDeepSleepConfig(XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_ENABLE_USB);</div>
<div class="line">    XMC_SCU_POWER_WaitForInterrupt(XMC_SCU_POWER_MODE_DEEPSLEEP, <span class="keyword">false</span>);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You can disable/enable the clock sources in Deep Sleep power mode by adding the appropriate clock source into XMC_SCU_CLOCK_SetDeepSleepConfig().</dd></dl>
<h3><a class="anchor" id="section_emusb_device_low_power_rtos"></a>
emUSB-Device in RTOS environment</h3>
<p >Typically, RTOS decide to go to Idle state when no active tasks remain active. Often, the transition into Idle condition is accompanied by entering the microcontroller in one of low-power modes (Depends on RTOS configuration). But the USB device must provide correct responses to all events on the USB bus. The preventing mechanism must be implemented, which does not allow the microcontroller to enter low-power mode when emUSB-Device is not in Suspended state. For example, for FreeRTOS, a custom implementation of vApplicationSleep() must be provided.</p>
<h3><a class="anchor" id="section_emusb_device_low_power_lpm"></a>
Link Power Management (LPM)</h3>
<p >emUSB-Device supports the Link Power Management feature like the configuration BESL (Best Effort Service Latency) value and reports on LPM transition on USB lines (L0 &lt;--&gt; L1).</p>
<p >To enable LPM:</p><ol type="1">
<li>Call the USBD_UseV210() function in USBD_X_Config().</li>
<li>(optional) Set the recommended BESL values by USBD_SetBESLValues().</li>
<li>Register the callback, which reports on the LPM state transition by USBD_SetOnLPMChange().</li>
<li>Define the behavior of the device on LPM request from the Host by USBD_SetLPMResponse() (reject or acknowledge the LPM request). Call USBD_SetLPMResponse() after USBD_Start(), otherwise, the response configuration may be lost.</li>
</ol>
<p >Based on the received BESL value, the application can determine the level of the power optimization and select appropriate low-power modes. The behavior of the USB IP block during low-power modes for each device described in <a class="el" href="index.html#section_emusb_device_low_power">Low Power Support</a>.</p>
<dl class="section note"><dt>Note</dt><dd>For the CAT1A device, USB_DRIVER_Cypress_PSoC6_SysTick() must be called every millisecond and USB_DRIVER_Cypress_PSoC6_Resume() after a wake-up from Deep Sleep as well as for Suspend functionality.</dd></dl>
<p>For more information about LPM, refer to "USB 2.0 Link Power Management
Addendum" and "Errata for USB 2.0 ECN: Link Power Management (LPM) - 7/2007" from usb.org.</p>
<dl class="section note"><dt>Note</dt><dd>CAT3 devices do not support LPM features.</dd></dl>
<h2><a class="anchor" id="section_emusb_device_only_pdl"></a>
Only PDL APIs support</h2>
<p >By default, emUSB-Device requires HAL APIs for operation. However, when HAL APIs cannot be used in the application, the USBD_USE_PDL option is available. With this macro set to 1, the emUSB-Device middleware will use PDL APIs instead of HAL APIs. When USBD_USE_PDL=1, the application must disable the standard debug output (USBD_DISABLE_STANDARD_OUTPUT=1) and, in a non-RTOS environment, provide the custom implementation for USB_OS_GetTickCnt() function (USBD_NORTOS_TICKCNT_ENABLE=0). The USBD_USE_PDL macro must be set in the DEFINES variable in the application project Makefile.</p>
<dl class="section note"><dt>Note</dt><dd>This section is applicable only for CAT1A devices.</dd></dl>
<h2><a class="anchor" id="section_emusb_device_pick_lib"></a>
Picking an emUSB-Device Library Variant</h2>
<p >The Middleware provides emUSB-Device as pre-build libraries. The pre-build libraries are selected automatically based on configurations of Makefile configurations. The table below shows the availability of the configuration options.</p>
<table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Make Variable </th></tr>
<tr>
<td>Device family </td><td>CAT1A, CAT3 </td><td>DEVICE_COMPONENTS  </td></tr>
<tr>
<td>Build configuration </td><td>Debug, Release </td><td>CONFIG  </td></tr>
<tr>
<td>Core </td><td><ul>
<li>CM0P, CM4 for CAT1A;</li>
<li>CM4 for CAT3;  </li>
</ul>
</td><td>CORE  </td></tr>
<tr>
<td>Floating point </td><td>hardfp, softfp </td><td>VFP_SELECT  </td></tr>
<tr>
<td>Toolchain </td><td>GCC_ARM, IAR, ARM </td><td>TOOLCHAIN  </td></tr>
</table>
<dl class="section warning"><dt>Warning</dt><dd>CAT3 device family supports only GCC_ARM compiler</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Typically, the device family and core are selected in BSP Makefile.</dd>
<dd>
CM0P supports only softfp.</dd></dl>
<h3><a class="anchor" id="section_emusb_device_lib_conf"></a>
Pre-build libraries configuration</h3>
<p >Some of the parameters/features of emUSB-Device are configured by the compile-time options (like the number of the interface that supports the ISO transfer, etc) during generation of pre-build libraries and cannot change in run-time. Header file USBD_ConfDefaults.h under the USBD directory contains the common compile time options used during pre-build libraries creation. Similarly, USBD_Conf.h under each COMPONENT_&lt;Device family&gt;/CONFIG_&lt; Build configuration&gt; directory contains the compile time options specific to the set of library variants. The compile time options defined in USBD_Conf.h have a higher priority than in USBD_ConfDefaults.h. Most of the compile time options are defined in these two header files but some are not visible like the macro, which define the number of interfaces. This section describes the compile time options not defined in USBD_Conf.h and USBD_ConfDefaults.h.</p>
<p >This table shows the number of supported interfaces for each class between the device families.</p>
<table class="doxtable">
<tr>
<th>USB Class</th><th>CAT1A</th><th>CAT3 </th></tr>
<tr>
<td>Audio </td><td>1 </td><td>1  </td></tr>
<tr>
<td>Legacy Audio </td><td>1 </td><td>1  </td></tr>
<tr>
<td>Bulk </td><td>4 </td><td>4  </td></tr>
<tr>
<td>CCID </td><td>1 </td><td>1  </td></tr>
<tr>
<td>CDC </td><td>2 </td><td>2  </td></tr>
<tr>
<td>HID </td><td>2 </td><td>2  </td></tr>
<tr>
<td>MSD </td><td>1 </td><td>1  </td></tr>
<tr>
<td>MTP </td><td>1 </td><td>1  </td></tr>
<tr>
<td>Printer </td><td>1 </td><td>1  </td></tr>
<tr>
<td>VirtualMSD </td><td>1 </td><td>1  </td></tr>
<tr>
<td>VSC </td><td>Limited by USB_MAX_NUM_IF </td><td>Limited by USB_MAX_NUM_IF  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The MSD and MTP classes support the connection to up-to-four logical/storage units.</dd></dl>
<h2><a class="anchor" id="section_emusb_device_use_in_rtos"></a>
Using emUSB-Device in an RTOS Environment</h2>
<p >The emUSB-device has been already implemented the Target OS Interface for both RTOS and non-RTOS aware environments. Selecting the OS layer implementation is automatic based on the <em>RTOS_AWARE</em> component. To inform the emUSB-Device that an RTOS environment is being used, set the <em>RTOS_AWARE</em> component (<em>COMPONENTS+=RTOS_AWARE</em>).</p>
<p >For the RTOS environment, the OS layer uses the <a href="https://github.com/Infineon/abstraction-rtos"><b>abstraction-rtos</b></a> library, and as a result, the emUSB-Device can be used with RTOSes supported by the <a href="https://github.com/Infineon/abstraction-rtos"><b>abstraction-rtos</b></a> library.</p>
<p >Specific implementation of Target OS Interface: </p><ul>
<li>
USB_OS_DecRI() and USB_OS_IncDI() have only alternate implementation because the USBD_OS_USE_USBD_X_INTERRUPT compile time option is enabled. Alternate implementation is more effective compared to the standard one because it allows disabling/enabling USB interrupts only before entering/exiting the critical section for emUSB-device.  </li>
<li>
The emUSB-Device middleware calls some functions of the OS layer from the USB interrupt. As a result, the USB interrupt priority must be aligned with the RTOS configuration. For example, for FreeRTOS, the USB interrupt must have a lower or equal priority to the MAX_API_CALL_INTERRUPT_PRIORITY macro.  </li>
<li>
<p class="startli">For non-RTOS environments: For <b>CAT1A</b> devices: USB_OS_GetTickCnt() configures one instance of the timer by <code>Timer (Timer/Counter)</code> Driver of HAL library for returning the current system time in milliseconds. The timer is started by initializing the emUSB-Device middleware.</p>
<p class="interli">To use USB_OS_GetTickCnt() with <b>CAT3</b> devices:</p><ol type="1">
<li>Enable emUSB OS Timer personality in the Device <em>Configurator-&gt;Peripherals-&gt;Digital-&gt;CCU4</em> section: <div class="image">
<img src="cat3_emusb_os_timer_section.png" alt=""/>
</div>
</li>
<li>Select the <em>Device</em> mode of emUSB personality. Select the CCU4 configured as emUSB OS Timer from the drop down list of "CCU for OS" section of emUSB personality. <div class="image">
<img src="cat3_emusb_device_os.png" alt=""/>
</div>
 USB_OS_GetTickCnt() configures the 1 millisecond timer using CCU4 driver reserved by emUSB OS Timer personality. The interrupt priority of reserved CCU4 is 63.</li>
</ol>
<p class="interli">USB_OS_GetTickCnt() own implementation can be provided due to: </p><ul>
<li>
The optimization of handling the ISR routine (the timer generates an interrupt every 1 millisecond);  </li>
<li>
Providing more reliable implementation (the timer value reloads every 49 days, 17 hours, 2 mins, 47.296 seconds);  </li>
<li>
The optimization of the HW resources usage (one instance of the TCPWM counter or similar HW resources, which can be used by <code>Timer (Timer/Counter)</code> Driver);  </li>
</ul>
<p>To do that, set the USBD_NORTOS_TICKCNT_ENABLE macro value to zero in Makefile file.</p>
<dl class="section note"><dt>Note</dt><dd><b>For CAT1A devices:</b> The own implementation of USB_OS_GetTickCnt() must be provided if the application uses the transit into Deep Sleep or Hibernate low-power modes.  </dd></dl>
</li>
<li>
For Free-RTOS, USB tasks priority must be lower than the priority of RTOS daemon tasks (also known as timer service tasks). The RTOS daemon task priority is defined in configTIMER_TASK_PRIORITY.  </li>
</ul>
<p >For details on Target OS Interface, refer to the - <a href="./../UM09001_emUSBD.pdf"><b>SEGGER emUSB-Device User Guide &amp; Reference Manual</b></a> Target OS Interface chapter.</p>
<h1><a class="anchor" id="section_emusb_device_package_str"></a>
emUSB-Device Package Structure</h1>
<p >The Middleware structure:</p><ul>
<li><b>export/Config:</b> Contains sample configuration files for hardware-specific configuration.</li>
<li><b>OS:</b> Contains the OS layer implementation.</li>
<li><b>USBD:</b> Contains a set of pre-build emUSB-Device libraries for different configurations of user applications (Device family, Build configuration, Core, Floating point, Toolchain), and a set of header files.</li>
<li><b>tool:</b> Contains the tool for code generation (Audio class only).</li>
<li><b>docs:</b> Contains the API Reference Guide, SEGGER-provided emUSB-Device User Guide &amp; Reference Manual and other supporting documentation.</li>
</ul>
<h1><a class="anchor" id="section_emusb_device_changelog"></a>
Changelog</h1>
<p >Note that the emUSB-Device Middleware by Infineon and emUSB-Device stack by Segger have different versions</p>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td rowspan="4">1.4.0 </td><td>Add a new driver for PSoC 6 with DMA support. Now for PSoC 6, the total size of all endpoints is not limited by 512 bytes for DMA driver. </td><td>Extending the supported features for emUSB-Device middleware  </td></tr>
<tr>
<td>Updated the emUSB-Device stack to 3.64.1 </td><td>New version is available  </td></tr>
<tr>
<td>Add the props.json file </td><td>Improve the integration with the ModusToolbox 3.0+ flow  </td></tr>
<tr>
<td>Update usbd_config.c file for CAT3 to support OTG. OTG feature is supported in emUSB-Device and emUSB-Host middleware </td><td>Extending the supported features for emUSB-Device middleware  </td></tr>
<tr>
<td rowspan="6">1.3.0 </td><td>Added support of Smart Card Device Class (CCID) </td><td>Extending the supported features for emUSB-Device middleware  </td></tr>
<tr>
<td>Added new Audio class with extended features like compatibility to USB Audio version 2 device class, explicit feedback and others. The legacy Audio class is not recommended to use in new applications. </td><td>Extending the supported features for emUSB-Device middleware  </td></tr>
<tr>
<td>Updated the emUSB-Device stack to 3.62.0 </td><td>New version is available  </td></tr>
<tr>
<td>Added the new compile time option to allow use emUSB-Device without HAL library. For details, refer to the <a class="el" href="index.html#section_emusb_device_only_pdl">Only PDL APIs support</a>.  </td><td>Extending the supported features for emUSB-Device middleware  </td></tr>
<tr>
<td>The maximum number of alternative interfaces are increased from 2 to 4 for all supported device families (See the USB_MAX_NUM_ALT_IF macro in the USB_Conf.h file). </td><td></td></tr>
<tr>
<td>Minor documentation updates </td><td></td></tr>
<tr>
<td rowspan="4">1.2.0 </td><td>Provided support for CAT3 devices. </td><td></td></tr>
<tr>
<td>Updated the emUSB-Device stack to 3.60.1 </td><td>New version is available  </td></tr>
<tr>
<td>Added a new section in the documentation <a class="el" href="index.html#section_emusb_device_lib_conf">Pre-build libraries configuration</a>  </td><td></td></tr>
<tr>
<td>Minors improvements in OS layer </td><td></td></tr>
<tr>
<td rowspan="8">1.1.0 </td><td>Updated the emUSB-Device stack to 3.58.0 </td><td>New version is available  </td></tr>
<tr>
<td>Added support of Audio class </td><td>Extending the supported features for emUSB-Device middleware  </td></tr>
<tr>
<td>The OS layer uses abstraction-rtos APIs instead of FreeRTOS. This means that emUSB-Device can be used with RTOS supported by abstraction-rtos including FreeRTOS  </td><td>Extend the number of supported RTOS  </td></tr>
<tr>
<td>The next compile time options were updated for CAT1A devices:<ul>
<li>The maximum numbers of DATA Endpoints increased from 7 -&gt; 8 (See the USB_NUM_EPS macro in the USB_Conf.h file), <dl class="section note"><dt>Note</dt><dd>USB_NUM_EPS define number data endpoints + 1 control endpoint</dd></dl>
</li>
<li>The maximum numbers of Bulk interface increased from 1 -&gt; 4</li>
<li>The maximum number of interface association descriptors increased 3 -&gt; 4 (See the USB_MAX_NUM_IAD macro in the USB_Conf.h file).</li>
<li>The maximum number of Microsoft OS descriptors increased from 3 -&gt; 4 (See the USB_MAX_NUM_MS_DESC macro in the USB_Conf.h file).  </li>
</ul>
</td><td>Extending the supported features for CAT1A devices  </td></tr>
<tr>
<td>Added remote wake-up functionality for CAT1A devices </td><td>Extending the supported features for CAT1A devices  </td></tr>
<tr>
<td>Updated the implementation of Debug Message Output. The usbd_config_io.c file became more friendly for updating and a USBD_DISABLE_STANDARD_OUTPUT macro was added. For details, refer to <a class="el" href="index.html#section_emusb_device_debug_mes_out">Debug Message Output</a>  </td><td>Improved the usability of Debug Message Output  </td></tr>
<tr>
<td>Added a new section in the documentation <a class="el" href="index.html#section_emusb_device_low_power_lpm">Link Power Management (LPM)</a>  </td><td></td></tr>
<tr>
<td>Minor documentation updates </td><td></td></tr>
<tr>
<td>1.0.1 </td><td>Updating the LICENSE file </td><td></td></tr>
<tr>
<td>1.0.0 </td><td>Initial release of emUSB-Device stack 3.52.2 </td><td></td></tr>
</table>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>emusb-device</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
